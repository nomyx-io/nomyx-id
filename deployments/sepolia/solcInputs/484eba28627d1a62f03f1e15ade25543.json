{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "src/facets/IdentityRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IIdentityRegistry.sol\";\nimport \"../libraries/IdentityLib.sol\";\nimport \"../libraries/TrustedIssuerLib.sol\";\nimport \"../utilities/Modifiers.sol\";\n\nimport \"../interfaces/ITrustedIssuersRegistry.sol\";\nimport \"../interfaces/IClaimTopicsRegistry.sol\";\n\nimport { IIdentityRegistry, IIdentity } from \"../interfaces/IIdentityRegistry.sol\";\n\n/// @title IdentityRegistryFacet\n/// @notice This contract manages the identity registry\n/// @dev This contract is meant to be used via diamond proxy\ncontract IdentityRegistryFacet is IIdentityRegistry, Modifiers {\n\tusing IdentityLib for IdentityContract;\n    using TrustedIssuerLib for TrustedIssuerContract;\n\n\tevent ContractAddressesSet();\n\n\tmodifier isTrustedIssuer() {\n\t\trequire(ITrustedIssuersRegistry(address(this)).isTrustedIssuer(msg.sender), \"Not trusted issuer\");\n\t\t_;\n\t}\n\n\tconstructor() {}\n\n\t/// @notice add an identity to the registry\n\t/// @param _identity address of the identity\n\t/// @param identityData address of the identity data contract\n    function _addIdentity(address _identity, IIdentity identityData) internal {\n        IdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n        Identity storage idObj = _contract._getIdentity(_identity);\n        require(idObj.identityData == IIdentity(address(0)), \"Identity already exists\");\n        idObj.identityData = identityData;\n        _contract.identityOwners.push(_identity);\n        emit IdentityAdded(_identity, identityData);\n    }\n\n\t/// @notice add an identity to the registry\n\t/// @param _identity address of the identity contract\n\t/// @param identityData address of the identity data contract\n\t/// @dev this function can only be called by a trusted issuer\n\tfunction addIdentity(address _identity, IIdentity identityData) external override isTrustedIssuer {\n       _addIdentity(_identity, identityData);\n    }\n\n\t/// @notice remove an identity from the registry\n\t/// @param _identity address of the identity contract\n\t/// @dev this function can only be called by a trusted issuer\n\tfunction removeIdentity(address _identity) external override isTrustedIssuer {\n        IdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n        Identity storage idObj = _contract._getIdentity(_identity);\n        require(idObj.identityData != IIdentity(address(0)), \"Identity does not exist\");\n        delete _contract.identities[_identity];\n        emit IdentityRemoved(_identity, idObj.identityData);\n    }\n\n\t/// @notice get the identity data contract address of an identity\n\t/// @param _userAddress address of the identity user\n\t/// @return identityData address of the identity data contract\n\tfunction identity(address _userAddress) external view override returns (IIdentity) {\n        IdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n        return _contract._getIdentity(_userAddress).identityData;\n    }\n\n\t/// @notice batch add identities to the registry\n\t/// @param _identities array of addresses of the identities\n\t/// @param identityDatas array of addresses of the identity data contracts\n\t/// @dev this function can only be called by a trusted issuer\n\tfunction batchAddIdentity(address[] calldata _identities, IIdentity[] calldata identityDatas) external override isTrustedIssuer {\n        require(_identities.length == identityDatas.length, \"Arrays length mismatch\");\n        for (uint256 i = 0; i < _identities.length; i++) {\n            _addIdentity(_identities[i], identityDatas[i]);\n        }\n\t}\n\n\t/// @notice add claim to an identity\n\t/// @param _identity address of the identity contract\n\t/// @param _claimTopic claim topic\n\t/// @param _claim claim data\n\t/// @dev this function can only be called by a trusted issuer\n\tfunction addClaim(address _identity, uint256 _claimTopic, bytes calldata _claim) external override isTrustedIssuer {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\tIdentity storage idObj = _contract._getIdentity(_identity);\n\t\trequire(!idObj.claimTopics[_claimTopic], \"Claim already exists\");\n\t\tidObj.claims[_claimTopic] = _claim;\n\t\tidObj.claimTopics[_claimTopic] = true;\n\t\temit ClaimAdded(_identity, _claimTopic, _claim);\n\t}\n\n\t/// @notice remove claim from an identity\n\t/// @param _identity address of the identity contract\n\t/// @param _claimTopic claim topic\n\t/// @dev this function can only be called by a trusted issuer\n\tfunction removeClaim(address _identity, uint256 _claimTopic) external override isTrustedIssuer {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\tIdentity storage idObj = _contract._getIdentity(_identity);\n\t\trequire(idObj.claimTopics[_claimTopic], \"Claim does not exist\");\n\t\tdelete idObj.claims[_claimTopic];\n\t\tdelete idObj.claimTopics[_claimTopic];\n\t\temit ClaimRemoved(_identity, _claimTopic);\n\t}\n\n\t/// @notice does an identity exist\n\t/// @param _userAddress address of the identity user\n\t/// @return bool\n\tfunction contains(address _userAddress) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract._getIdentity(_userAddress).identityData != IIdentity(address(0));\n\t}\n\n\t/// @notice is an identity verified\n\t/// @param _userAddress address of the identity user\n\t/// @return bool\n\tfunction isVerified(address _userAddress) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract._getIdentity(_userAddress).identityData.isVerified();\n\t}\n\n\t/// @notice get the users of the registry\n\t/// @return array of addresses of the users\n\tfunction getRegistryUsers() external view override returns (address[] memory) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract.identityOwners;\n\t}\n\n\t/// @notice is the user a registry user\n\t/// @param _registryUser address of the registry user\n\t/// @return bool\n\tfunction isRegistryUser(address _registryUser) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract._getIdentity(_registryUser).identityData != IIdentity(address(0));\n\t}\n\n\t/// @notice get the claims of an identity\n\t/// @param _registryUser address of the registry user\n\t/// @return array of claim topics\n\tfunction getClaims(address _registryUser) external view override returns (uint256[] memory) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\tIdentity storage idObj = _contract._getIdentity(_registryUser);\n\t\tuint256[] memory claims = new uint256[](idObj.identityData.getClaimTopics().length);\n\t\tfor (uint256 i = 0; i < idObj.identityData.getClaimTopics().length; i++) {\n\t\t\tclaims[i] = idObj.identityData.getClaimTopics()[i];\n\t\t}\n\t\treturn claims;\n\t}\n\n\t/// @notice get the claim of an identity\n\t/// @param _registryUser address of the registry user\n\t/// @param _claimTopic claim topic\n\t/// @return claim data\n\tfunction getClaim(address _registryUser, uint256 _claimTopic) external view override returns (bytes memory) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\tIdentity storage idObj = _contract._getIdentity(_registryUser);\n\t\treturn idObj.claims[_claimTopic];\n\t}\n\n\t/// @notice does an identity have a claim\n\t/// @param _registryUser address of the registry user\n\t/// @param _claimTopic claim topic\n\t/// @return bool\n\tfunction hasClaim(address _registryUser, uint256 _claimTopic) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\tIdentity storage idObj = _contract._getIdentity(_registryUser);\n\t\treturn idObj.claimTopics[_claimTopic];\n\t}\n\n\t/// @notice get the onchain ID of an identity\n\t/// @param _userAddress address of the registry user\n\t/// @return onchainID onchain ID\n\tfunction getOnchainIDFromWallet(address _userAddress) external view override returns (bytes32) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract.addressToOnchainID[_userAddress];\n\t}\n\n\t/// @notice is the wallet linked to an onchain ID\n\t/// @return bool\n\tfunction walletLinked(bytes32) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract.identityAddresses.length > 0;\n\t}\n\n\t/// @notice get the wallet addresses of an onchain ID\n\t/// @param _onchainID onchain ID\n\t/// @dev this function can only be called by a trusted issuer\n\tfunction unlinkWallet(bytes32 _onchainID) external override isTrustedIssuer {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\trequire(_contract.identityAddresses.length > 0, \"No linked wallet\");\n\t\taddress _walletAddress = _contract.identityAddresses[_contract.identityAddresses.length - 1];\n\t\t_contract.addressToOnchainID[_walletAddress] = bytes32(0);\n\t\t_contract.identityAddresses.pop();\n\t\temit WalletUnlinked(_walletAddress, _onchainID);\n\t}\n\n\t/// @notice unlink a wallet address from an onchain ID\n\t/// @param _walletAddress address of the wallet\n\t/// @dev this function can only be called by a trusted issuer\n\tfunction unlinkWalletAddress(address _walletAddress) external override isTrustedIssuer {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\trequire(_contract.identityAddresses.length > 0, \"No linked wallet\");\n\t\tbytes32 _onchainID = _contract.addressToOnchainID[_walletAddress];\n\t\t_contract.addressToOnchainID[_walletAddress] = bytes32(0);\n\t\t_contract.identityAddresses.pop();\n\t\temit WalletUnlinked(_walletAddress, _onchainID);\n\t}\n\n\t/// @notice link a wallet address to an onchain ID\n\t/// @param _walletAddress address of the wallet\n\tfunction walletAddressLinked(address _walletAddress) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract.addressToOnchainID[_walletAddress] != bytes32(0);\n\t}\n\n}\n"
    },
    "src/facets/TrustedIsssuersRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IClaimIssuer } from \"../interfaces/IClaimIssuer.sol\";\nimport { ITrustedIssuersRegistry } from \"../interfaces/ITrustedIssuersRegistry.sol\";\nimport { Modifiers } from \"../utilities/Modifiers.sol\";\n\nimport \"../libraries/TrustedIssuerLib.sol\";\n\n/// @title TrustedIssuersRegistryFacet\n/// @notice This contract is used to manage the trusted issuers registry\ncontract TrustedIssuersRegistryFacet is ITrustedIssuersRegistry, Modifiers {\n\tusing TrustedIssuerLib for TrustedIssuerContract;\n\n\t/// @notice get the trusted issuer struct given the trusted issuer address\n\t/// @param issuerAddress The address of the trusted issuer\n\t/// @return trustedIssuer The trusted issuer struct\n\tfunction getTrustedIssuer(address issuerAddress) external view returns (TrustedIssuer memory) {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\treturn _contract._getTrustedIssuer(issuerAddress);\n\t}\n\n\tfunction setTrustedIssuer(address issuerAddress, TrustedIssuer memory trustedIssuer) external {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\t_contract._setTrustedIssuer(issuerAddress, trustedIssuer);\n\t}\n\n\tfunction addTrustedIssuer(address _trustedIssuer, uint[] calldata _claimTopics) external onlyOwner {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\t_contract._addTrustedIssuer(_trustedIssuer, _claimTopics);\n\t}\n\n\tfunction removeTrustedIssuer(address _trustedIssuer) external onlyOwner {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\t_contract.removeTrustedIssuer(_trustedIssuer);\n\t}\n\n\tfunction updateIssuerClaimTopics(address _trustedIssuer, uint[] calldata _claimTopics) external {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\t_contract.updateIssuerClaimTopics(_trustedIssuer, _claimTopics);\n\t}\n\n\tfunction getTrustedIssuers() external view override returns (TrustedIssuer[] memory) {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\treturn _contract.getTrustedIssuers();\n\t}\n\n\tfunction isTrustedIssuer(address _issuer) external view override returns (bool) {\n\t\treturn TrustedIssuerLib.isTrustedIssuer(_issuer);\n\t}\n\n\tfunction getTrustedIssuerClaimTopics(address _trustedIssuer) external view returns (uint[] memory) {\n\t\treturn TrustedIssuerLib.getTrustedIssuerClaimTopics(_trustedIssuer);\n\t}\n\n\tfunction hasClaimTopic(address _issuer, uint _claimTopic) external view override returns (bool) {\n\t\treturn TrustedIssuerLib.hasClaimTopic(_issuer, _claimTopic);\n\t}\n}\n"
    },
    "src/identity/Identity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IIdentity } from \"../interfaces/IIdentity.sol\";\nimport { Controllable } from \"../utilities/Controllable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { ITrustedIssuersRegistry } from \"../interfaces/ITrustedIssuersRegistry.sol\";\n\n/// @title Identity\n/// @notice This contract represents an identity of a user\n/// @dev This contract is used to store the claims of a user\ncontract Identity is IIdentity, Controllable, Initializable {\n\t\n\tmapping(bytes32 => Key) keys;\n\tmapping(uint256 => bytes32[]) keysByPurpose;\n\n\taddress identityRegistry;\n\taddress trustedIssuerRegistry;\n\n\tmodifier onlyTrustedIssuer() {\n\t\trequire(\n\t\t\tITrustedIssuersRegistry(trustedIssuerRegistry).isTrustedIssuer(msg.sender),\n\t\t\t\"Sender is not a trusted issuer\"\n\t\t);\n\t\t_;\n\t}\n\n\t/**\n\t * initialize the contract\n\t * @param _owner the owner of the contract\n\t * @param _identityRegistry the identity registry\n\t * @param _trustedIssuerRegistry the trusted issuer registry\n\t */\n\tfunction initialize(address _owner, address _identityRegistry, address _trustedIssuerRegistry) external initializer {\n\t\t_addController(_owner);\n\t\tidentityRegistry = _identityRegistry;\n\t\ttrustedIssuerRegistry = _trustedIssuerRegistry;\n\t}\n\n\tstruct Key {\n\t\tuint256[] purposes;\n\t\tuint256 keyType;\n\t\tbytes32 key;\n\t}\n\n\tfunction addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external override onlyTrustedIssuer {\n\t\trequire(keys[_key].key != _key, \"Key already exists\");\n\n\t\tkeys[_key].key = _key;\n\t\tkeys[_key].purposes.push(_purpose);\n\t\tkeys[_key].keyType = _keyType;\n\n\t\tkeysByPurpose[_purpose].push(_key);\n\n\t\temit KeyAdded(_key, _purpose, _keyType);\n\t}\n\n\tfunction removeKey(bytes32 _key, uint256 _purpose) external override onlyTrustedIssuer {\n\t\trequire(keys[_key].key == _key, \"No such key\");\n\t\tfor (uint i = 0; i < keys[_key].purposes.length; i++) {\n\t\t\tif (keys[_key].purposes[i] == _purpose) {\n\t\t\t\tdelete keys[_key].purposes[i];\n\t\t\t}\n\t\t}\n\n\t\temit KeyRemoved(_key, _purpose, keys[_key].keyType);\n\n\t\tdelete keys[_key];\n\t}\n\n\tfunction getKey(\n\t\tbytes32 _key\n\t) external view override returns (uint256[] memory purposes, uint256 keyType, bytes32 key) {\n\t\treturn (keys[_key].purposes, keys[_key].keyType, keys[_key].key);\n\t}\n\n\tfunction getKeyPurposes(bytes32 _key) external view override returns (uint256[] memory _purposes) {\n\t\treturn (keys[_key].purposes);\n\t}\n\n\tfunction getKeysByPurpose(uint256 _purpose) external view override returns (bytes32[] memory _keys) {\n\t\treturn (keysByPurpose[_purpose]);\n\t}\n\n\tfunction _keyHasPurpose(bytes32 _key, uint256 _purpose) internal view returns (bool exists) {\n\t\tif (keys[_key].key == 0) return false;\n\t\tfor (uint i = 0; i < keys[_key].purposes.length; i++) {\n\t\t\tif (keys[_key].purposes[i] == _purpose) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists) {\n\t\treturn _keyHasPurpose(_key, _purpose);\n\t}\n\n\tfunction execute(address _to, uint256 _value, bytes calldata _data) external payable onlyTrustedIssuer returns (uint256 executionId) {\n\t\trequire(_keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have rights\");\n\t\t(bool success, ) = _to.call{value: _value}(_data);\n\t\tif (success) {\n\t\t\temit Executed(executionId, _to, _value, _data);\n\t\t} else {\n\t\t\temit ExecutionFailed(executionId, _to, _value, _data);\n\t\t}\n\t\treturn executionId;\n\t}\n\n\tfunction approve(uint256 _id, bool _approve) external override onlyTrustedIssuer {\n\t\trequire(_keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have rights\");\n\t\tif (_approve) {\n\t\t\temit Approved(_id, true);\n\t\t} else {\n\t\t\temit Approved(_id, false);\n\t\t}\n\t}\n\n\tstruct Claim {\n\t\tuint256 topic;\n\t\tuint256 scheme;\n\t\taddress issuer;\n\t\tbytes signature;\n\t\tbytes data;\n\t\tstring uri;\n\t}\n\n\tmapping(bytes32 => Claim) internal claims;\n\tbytes32[] internal claimIds;\n\n\tmapping(uint256 => bytes32[]) internal claimsByTopic;\n\tbytes32[] internal claimTopics;\n\n\tfunction getClaim(bytes32 _claimId)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (\n\t\t\tuint256 topic,\n\t\t\tuint256 scheme,\n\t\t\taddress issuer,\n\t\t\tbytes memory signature,\n\t\t\tbytes memory data,\n\t\t\tstring memory uri\n\t\t) {\n\t\tClaim storage claim = claims[_claimId];\n\t\treturn (claim.topic, claim.scheme, claim.issuer, claim.signature, claim.data, claim.uri);\n\t}\n\n\tfunction getClaimIdsByTopic(uint256 _topic) external view override returns (bytes32[] memory claimIds_) {\n\t\tclaimIds_ = claimsByTopic[_topic];\n\t}\n\n\tfunction addClaim(\n\t\tuint256 _topic,\n\t\tuint256 _scheme,\n\t\taddress _issuer,\n\t\tbytes memory _signature,\n\t\tbytes memory _data,\n\t\tstring memory _uri\n\t) external override onlyTrustedIssuer returns (uint256 claimRequestId) {\n\n\t\tbytes32 claimId = keccak256(abi.encodePacked(_issuer, _topic));\n\n\t\tClaim storage claim = claims[claimId];\n\t\tclaim.topic = _topic;\n\t\tclaim.scheme = _scheme;\n\t\tclaim.issuer = _issuer;\n\t\tclaim.signature = _signature;\n\t\tclaim.data = _data;\n\t\tclaim.uri = _uri;\n\n\t\tclaimsByTopic[_topic].push(claimId);\n\t\tclaimTopics.push(claimId);\n\n\t\tclaims[claimId] = claim;\n\t\tclaimIds.push(claimId);\n\n\t\temit ClaimAdded(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n\n\t\treturn _topic;\n\t}\n\n\tfunction changeClaim(\n\t\tbytes32,\n\t\tuint256,\n\t\tuint256,\n\t\taddress,\n\t\tbytes memory,\n\t\tbytes memory,\n\t\tstring memory\n\t) external pure override returns (bool) {\n\t\trequire(false, \"Not implemented\");\n\t}\n\n\tfunction removeClaim(bytes32 _claimId) external override onlyTrustedIssuer returns (bool success) {\n\t\tClaim storage claim = claims[_claimId];\n\t\trequire(claim.issuer != address(0), \"Claim does not exist\");\n\t\tdelete claims[_claimId];\n\t\temit ClaimRemoved(_claimId, claim.topic, claim.scheme, claim.issuer, claim.signature, claim.data, claim.uri);\n\t\treturn true;\n\t}\n\n\tfunction supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n\t\treturn interfaceId == type(IIdentity).interfaceId;\n\t}\n\n\tfunction getExecution(\n\t\tuint256\n\t)\n\t\texternal\n\t\tpure\n\t\toverride\n\t\treturns (address, uint256, bytes memory, bool, uint256)\n\t{\n\t\trequire(false, \"Not implemented\");\n\t}\n\n\t function getClaimTopics() external view override returns (uint256[] memory) {\n\t\t uint256[] memory _claimTopics = new uint256[](claimTopics.length);\n\t\t for (uint256 i = 0; i < claimTopics.length; i++) {\n\t\t\t _claimTopics[i] = claims[claimTopics[i]].topic;\n\t\t }\n\t\t return _claimTopics;\n\t }\n\n\t function isVerified() external view returns (bool) {}\n}"
    },
    "src/IdentityFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./identity/Identity.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\ncontract IdentityFactory is Initializable, Ownable {\n    address private _template;\n    address private _trustedIssuerRegistry;\n    address private _identityRegistry;\n\n    mapping(address => address) private _identities;\n    address[] private _identityList;\n\n    event IdentityCreated(address indexed owner, address indexed identity);\n\n    constructor() {\n        _template = address(new Identity());\n    }\n\n    /**\n     * init the fdactory with the registries\n     * @param identityRegistry the identity registry\n     * @param trustedIssuerRegistry the trusted issuer registry\n     */\n    function initialize(address identityRegistry, address trustedIssuerRegistry) external initializer {\n\t\t_identityRegistry = identityRegistry;\n\t\t_trustedIssuerRegistry = trustedIssuerRegistry;\n\t}\n\n    /** \n     * create a new identity\n     */\n    function createIdentity(address ownerAddress) public onlyOwner {\n        // does the identify already exist?\n        require(address(_identities[ownerAddress]) == address(0), \"Identity already exists\");\n        address addr = Clones.clone(_template);\n        Identity(addr).initialize(ownerAddress, _identityRegistry, _trustedIssuerRegistry);\n        _identities[ownerAddress] = addr;\n        _identityList.push(addr);\n        emit IdentityCreated(msg.sender, addr);\n    }\n\n    /**\n     * get the identity of an owner\n     * @param owner the owner of the identity\n     * @return the identity\n     */\n    function getIdentity(address owner) public view returns (address) {\n        return _identities[owner];\n    }\n\n    /**\n     * get the list of identities\n     * @return the list of identities\n     */\n    function getIdentityUsers() public view returns (address[] memory) {\n        return _identityList;\n    }\n}"
    },
    "src/interfaces/IClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IIdentity.sol\";\n\nstruct Claim {\n    uint256 topic;\n    uint256 scheme;\n    address issuer;\n    bytes signature;\n    bytes data;\n    string uri;\n    bool isRemoved;\n}\n\ninterface IClaimIssuer is IIdentity {\n\n    event ClaimRevoked(bytes indexed signature);\n\n    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);\n    function revokeClaimBySignature(bytes calldata signature) external;\n    function isClaimRevoked(bytes calldata _sig) external view returns (bool);\n    function isClaimValid(\n        IIdentity _identity,\n        uint256 claimTopic,\n        bytes calldata sig,\n        bytes calldata data)\n    external view returns (bool);\n    function getRecoveredAddress(bytes calldata sig, bytes32 dataHash) external pure returns (address);\n    \n}"
    },
    "src/interfaces/IClaimTopicsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IClaimTopicsRegistry {\n\n    // events\n    event ClaimTopicAdded(uint256 indexed claimTopic);\n    event ClaimTopicRemoved(uint256 indexed claimTopic);\n\n    // functions\n    // setters\n    function addClaimTopic(uint256 _claimTopic) external;\n    function removeClaimTopic(uint256 _claimTopic) external;\n\n    // getter\n    function getClaimTopics() external view returns (uint256[] memory);\n\n}"
    },
    "src/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice a controllable contract interface. allows for controllers to perform privileged actions. controllera can other controllers and remove themselves.\r\ninterface IControllable {\r\n\r\n    /// @notice emitted when a controller is added.\r\n    event ControllerAdded(\r\n        address indexed contractAddress,\r\n        address indexed controllerAddress\r\n    );\r\n\r\n    /// @notice emitted when a controller is removed.\r\n    event ControllerRemoved(\r\n        address indexed contractAddress,\r\n        address indexed controllerAddress\r\n    );\r\n\r\n    /// @notice adds a controller.\r\n    /// @param controller the controller to add.\r\n    function addController(address controller) external;\r\n\r\n    /// @notice removes a controller.\r\n    /// @param controller the address to check\r\n    /// @return true if the address is a controller\r\n    function isController(address controller) external view returns (bool);\r\n\r\n    /// @notice remove ourselves from the list of controllers.\r\n    function relinquishControl() external;\r\n}\r\n"
    },
    "src/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n"
    },
    "src/interfaces/IDiamondToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IClaimTopicsRegistry } from \"./IClaimTopicsRegistry.sol\";\nimport { IIdentityRegistry } from \"./IIdentityRegistry.sol\";\nimport { ITrustedIssuersRegistry } from \"./ITrustedIssuersRegistry.sol\";\n\ninterface IDiamondToken is IClaimTopicsRegistry, IIdentityRegistry, ITrustedIssuersRegistry {}"
    },
    "src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/interfaces/IERC734.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"./IERC165.sol\";\n\ninterface IERC734 is IERC165 {\n    // events\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(\n        uint256 indexed executionId,\n        address indexed to,\n        uint256 indexed value,\n        bytes data\n    );\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    // functions\n    // setters\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external;\n    function removeKey(bytes32 _key, uint256 _purpose) external;\n    function approve(uint256 _id, bool _approve) external;\n\n    // getters\n    function getKey(bytes32 _key) external view returns(uint256[] memory purposes, uint256 keyType, bytes32 key);\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory);\n    function getKeysByPurpose(uint256 _purpose) external view returns(bytes32[] memory);\n    function getExecution(uint256 _id) external view returns(address to, uint256 value, bytes memory data, bool approved, uint256 executionType);\n}\n"
    },
    "src/interfaces/IERC735.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IERC735 {\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n\n    function getClaim(bytes32 _claimId) external returns(uint256 topic, uint256 scheme, address issuer, bytes memory signature, bytes memory data, string memory uri);\n    function getClaimIdsByTopic(uint256 _topic) external returns(bytes32[] memory claimIds);\n    function addClaim(\n        uint256 _topic, \n        uint256 _scheme, \n        address _issuer, \n        bytes memory _signature, \n        bytes memory _data, \n        string memory _uri) external returns (uint256 claimRequestId);\n    function changeClaim(bytes32 _claimId, uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) external returns (bool success);\n    function removeClaim(bytes32 _claimId) external returns (bool success);\n}\n\n/*\nHow IdentityRegistry works:\n\n1. User creates an Identity contract\n2. User calls IdentityRegistry.addIdentity(address _identity, IIdentity identityData)\n3. IdentityRegistry emits IdentityAdded(address indexed _address, IIdentity identity)\n4. IdentityRegistry emits ClaimAdded(address indexed identity, uint256 indexed claimTopic, bytes claim)\n5. IdentityRegistry emits WalletLinked(address indexed walletAddress, bytes32 indexed onchainID)\n\n*/"
    },
    "src/interfaces/IIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC734 } from \"./IERC734.sol\";\nimport { IERC735 } from \"./IERC735.sol\";\n\ninterface IIdentity is IERC734, IERC735 {\n    function isVerified() external view returns (bool);\n    function getClaimTopics() external view returns (uint256[] memory);\n}"
    },
    "src/interfaces/IIdentityRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport { IIdentity } from \"./IIdentity.sol\";\n\ninterface IIdentityRegistry {\n    // events\n    event IdentityAdded(address indexed _address, IIdentity identity);\n    event IdentityRemoved(address indexed _address, IIdentity identity);\n    event IdentityCountryUpdated(address indexed identity, uint16 indexed country);\n    event ClaimAdded(address indexed identity, uint256 indexed claimTopic, bytes claim);\n    event ClaimRemoved(address indexed identity, uint256 indexed claimTopic);\n    event WalletLinked(address indexed walletAddress, bytes32 indexed onchainID);\n    event WalletUnlinked(address indexed walletAddress, bytes32 indexed onchainID);\n\n    // functions\n    function addIdentity(address _identity, IIdentity identityData) external;\n    function batchAddIdentity(address[] calldata _identities, IIdentity[] calldata identityDatas) external;\n    function removeIdentity(address _identity) external;\n    function addClaim(address _identity, uint256 _claimTopic, bytes calldata _claim) external;\n    function removeClaim(address _identity, uint256 _claimTopic) external;\n\n    // registry consultation\n    function contains(address _userAddress) external view returns (bool);\n    function isVerified(address _userAddress) external view returns (bool);\n    function identity(address _userAddress) external view returns (IIdentity);\n\n    // getters\n    function getRegistryUsers() external view returns (address[] memory);\n    function isRegistryUser(address _registryUser) external view returns(bool);\n    function getClaims(address _registryUser) external view returns(uint256[] memory);\n    function getClaim(address _registryUser, uint256 _claimTopic) external view returns(bytes memory);\n    function hasClaim(address _registryUser, uint256 _claimTopic) external view returns(bool);\n\n    function getOnchainIDFromWallet(address _userAddress) external view returns (bytes32);\n    function walletLinked(bytes32 _onchainID) external view returns (bool);\n    function unlinkWallet(bytes32 _onchainID) external;\n    function unlinkWalletAddress(address _walletAddress) external;\n    function walletAddressLinked(address _walletAddress) external view returns (bool);\n}"
    },
    "src/interfaces/ITrustedIssuersRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IClaimIssuer } from \"./IClaimIssuer.sol\";\n\nstruct TrustedIssuer {\n    address claimIssuer;\n    uint[] claimTopics;\n}\n\ninterface ITrustedIssuersRegistry {\n\n    // events\n    event TrustedIssuerAdded(address indexed trustedIssuer, uint[] claimTopics);\n    event TrustedIssuerRemoved(address indexed trustedIssuer);\n    event ClaimTopicsUpdated(address indexed trustedIssuer, uint[] claimTopics);\n\n    // functions\n    // setters\n    function addTrustedIssuer(address _trustedIssuer, uint[] calldata _claimTopics) external;\n    function removeTrustedIssuer(address _trustedIssuer) external;\n    function updateIssuerClaimTopics(address _trustedIssuer, uint[] calldata _claimTopics) external;\n\n    // getters\n    function getTrustedIssuers() external view returns (TrustedIssuer[] memory);\n    function isTrustedIssuer(address _issuer) external view returns(bool);\n    function getTrustedIssuerClaimTopics(address _trustedIssuer) external view returns(uint[] memory);\n    function hasClaimTopic(address _issuer, uint _claimTopic) external view returns(bool);\n\n}"
    },
    "src/libraries/ClaimStorageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Claim } from \"../interfaces/IClaimIssuer.sol\";\n\nstruct ClaimStorage {\n    mapping(bytes32 => Claim) claims;\n}\n\nlibrary ClaimStorageLib {\n\n    using Strings for uint256;\n    using Address for address;\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nomyx.app.Claim.storage\");\n\n    function claimStorage() internal pure returns (ClaimStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function getClaim(bytes32 _claimId) internal view returns (Claim memory) {\n        return claimStorage().claims[_claimId];\n    }\n\n}"
    },
    "src/libraries/IdentityLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport {IIdentity} from \"../interfaces/IIdentity.sol\";\nimport {IIdentityRegistry} from \"../interfaces/IIdentityRegistry.sol\";\n\nstruct Identity {\n    IIdentity identityData;\n    uint16 country;\n    mapping(uint256 => bytes) claims;\n    mapping(uint256 => bool) claimTopics;\n}\n\nstruct IdentityContract {\n    mapping(address => Identity) identities;\n    address[] identityOwners;\n    address[] identityAddresses;\n    mapping(address => bytes32) addressToOnchainID;\n}\n\nstruct IdentityStorage {\n    IdentityContract identityContract;\n}\n\nlibrary IdentityLib {\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nomyx.IdentityRegistryFacet.IdentityStorage\");\n\n    event IdentityAdded(address indexed _address, IIdentity identity);\n    event IdentityRemoved(address indexed _address, IIdentity identity);\n\n    function identityStorage() internal pure returns (IdentityStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice get an Identity for an address\n    function _getIdentity(\n        IdentityContract storage,\n        address _identityAddress\n    ) internal view returns (Identity storage) {\n        return identityStorage().identityContract.identities[_identityAddress];\n    }\n\n    /// @notice set an Identity for a tokenid keyed by string\n    function _setIdentity(\n        IdentityContract storage self,\n        address _identityAddress,\n        Identity storage identity\n    ) internal {\n        self.identities[_identityAddress].identityData = identity.identityData;\n        self.identities[_identityAddress].country = identity.country;\n        self.identityAddresses.push(_identityAddress);\n        emit IdentityAdded(_identityAddress, identity.identityData);\n    }\n\n    /// @notice remove an Identity for an address\n    function _removeIdentity(\n        IdentityContract storage self,\n        address _identityAddress\n    ) internal {\n        delete self.identities[_identityAddress];\n        \n        uint256 index;\n        for (uint256 i = 0; i < self.identityAddresses.length; i++) {\n            if (self.identityAddresses[i] == _identityAddress) {\n                index = i;\n                break;\n            }\n        }\n        if (index != self.identityAddresses.length - 1) {\n            self.identityAddresses[index] = self.identityAddresses[self.identityAddresses.length - 1];\n        }\n        self.identityAddresses.pop();\n        emit IdentityRemoved(_identityAddress, self.identities[_identityAddress].identityData);\n    }\n\n}\n"
    },
    "src/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        //require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "src/libraries/TrustedIssuerLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IClaimIssuer } from \"../interfaces/IClaimIssuer.sol\";\nimport { ITrustedIssuersRegistry, TrustedIssuer } from \"../interfaces/ITrustedIssuersRegistry.sol\";\n\nstruct TrustedIssuerContract {\n    mapping(address => TrustedIssuer) trustedIssuers;\n    address[] trustedIssuerAddresses;\n    address owner;\n}\n\nstruct TrustedIssuerStorage {\n    TrustedIssuerContract trustedIssuerContract;\n}\n\n/// \nlibrary TrustedIssuerLib {\n\n    event TrustedIssuerUpdated(address indexed issuerAddress, TrustedIssuer trustedIssuer);\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nomyx.lenderlabs.TrustedIssuerStorage.storage\");\n\n    /// @notice Get the storage struct for the TrustedIssuerRegistry\n    /// @return ds TrustedIssuerStorage struct for the TrustedIssuerRegistry\n    function trustedIssuerStorage() internal pure returns (TrustedIssuerStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice Get the trusted issuer struct given the trusted issuer address \n    /// @param issuerAddress The address of the trusted issuer\n    /// @return trustedIssuer The trusted issuer struct\n    function _getTrustedIssuer(\n        TrustedIssuerContract storage,\n        address issuerAddress\n    ) internal view returns (TrustedIssuer memory trustedIssuer) {\n        return trustedIssuerStorage().trustedIssuerContract.trustedIssuers[issuerAddress];\n    }\n\n    /// @notice Set the trusted issuer struct given the trusted issuer address\n    /// @param self The TrustedIssuerContract storage struct\n    /// @param issuerAddress The address of the trusted issuer\n    /// @param trustedIssuer The trusted issuer struct\n    function _setTrustedIssuer(\n        TrustedIssuerContract storage self,\n        address issuerAddress,\n        TrustedIssuer memory trustedIssuer\n    ) internal {\n        if(self.trustedIssuers[issuerAddress].claimIssuer == address(0)) {\n            self.trustedIssuerAddresses.push(issuerAddress);\n        }\n        self.trustedIssuers[issuerAddress] = trustedIssuer; \n        emit TrustedIssuerUpdated(issuerAddress, trustedIssuer);\n    }\n\n    /// @notice Add a trusted issuer\n    /// @param _trustedIssuer The address of the trusted issuer\n    /// @param _claimTopics The claim topics that the trusted issuer is allowed to issue\n    function _addTrustedIssuer(\n        TrustedIssuerContract storage,\n        address _trustedIssuer, \n        uint[] calldata _claimTopics) internal {\n\n        TrustedIssuer memory trustedIssuer = TrustedIssuer({\n            claimIssuer: _trustedIssuer,\n            claimTopics: _claimTopics\n        });\n\n        _setTrustedIssuer(\n            trustedIssuerStorage().trustedIssuerContract,\n            address(_trustedIssuer),\n            trustedIssuer\n        );\n    }\n\n    /// @notice Remove a trusted issuer\n    /// @param self The TrustedIssuerContract storage struct\n    /// @param _trustedIssuer The address of the trusted issuer\n    function removeTrustedIssuer(TrustedIssuerContract storage self, address _trustedIssuer) internal {\n        delete self.trustedIssuers[address(_trustedIssuer)];\n    }\n\n    /// @notice Update the claim topics that a trusted issuer is allowed to issue\n    /// @param self The TrustedIssuerContract storage struct\n    /// @param _trustedIssuer The address of the trusted issuer\n    /// @param _claimTopics The claim topics that the trusted issuer is allowed to issue\n    function updateIssuerClaimTopics(TrustedIssuerContract storage self, address _trustedIssuer, uint[] calldata _claimTopics) internal {\n        TrustedIssuer memory trustedIssuer = _getTrustedIssuer(\n            self,\n            address(_trustedIssuer)\n        );\n        trustedIssuer.claimTopics = _claimTopics;\n        _setTrustedIssuer(\n            self,\n            address(_trustedIssuer),\n            trustedIssuer\n        );\n    }\n\n    /// @notice Get the trusted issuers\n    /// @param self The TrustedIssuerContract storage struct\n    /// @return trustedIssuers The trusted issuers\n    function getTrustedIssuers(TrustedIssuerContract storage self) internal view  returns (TrustedIssuer[] memory trustedIssuers) {\n        trustedIssuers = new TrustedIssuer[](self.trustedIssuerAddresses.length);\n        for (uint i = 0; i < self.trustedIssuerAddresses.length; i++) {\n            trustedIssuers[i] = self.trustedIssuers[self.trustedIssuerAddresses[i]];\n        }\n    }\n\n    /// @notice is the issuer trusted\n    /// @param _issuer The address of the issuer\n    /// @return isTrusted True if the issuer is trusted\n    function isTrustedIssuer(address _issuer) internal view returns(bool isTrusted) {\n        isTrusted = trustedIssuerStorage().trustedIssuerContract.trustedIssuers[_issuer].claimIssuer != address(0);\n    }\n\n    /// @notice Get the trusted issuer\n    /// @param _trustedIssuer The trusted issuer\n    /// @return trustedIssuer The trusted issuer\n    function getTrustedIssuerClaimTopics(address _trustedIssuer) external view returns(uint[] memory) {\n        return trustedIssuerStorage().trustedIssuerContract.trustedIssuers[address(_trustedIssuer)].claimTopics;\n    }\n\n    /// @notice Does this issuer have this claim topic\n    /// @param _issuer The address of the issuer\n    /// @param _claimTopic The claim topic\n    /// @return hasTopic True if the issuer has this claim topic\n    function hasClaimTopic(address _issuer, uint _claimTopic) external view returns(bool hasTopic) {\n        uint[] memory claimTopics = trustedIssuerStorage().trustedIssuerContract.trustedIssuers[_issuer].claimTopics;\n        for (uint i = 0; i < claimTopics.length; i++) {\n            if (claimTopics[i] == _claimTopic) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "src/utilities/Controllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../interfaces/IControllable.sol\";\r\n\r\nabstract contract Controllable is IControllable {\r\n    mapping(address => bool) internal _controllers;\r\n\r\n    /**\r\n     * @dev Throws if called by any account not in authorized list\r\n     */\r\n    modifier onlyController() virtual {\r\n        require(\r\n            _controllers[msg.sender] == true || address(this) == msg.sender,\r\n            \"caller is not a controller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Add an address allowed to control this contract\r\n     */\r\n    function addController(address _controller)\r\n        external\r\n        override\r\n        onlyController\r\n    {\r\n        _addController(_controller);\r\n    }\r\n    function _addController(address _controller) internal {\r\n        _controllers[_controller] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if this address is a controller\r\n     */\r\n    function isController(address _address)\r\n        external\r\n        view\r\n        override\r\n        returns (bool allowed)\r\n    {\r\n        allowed = _isController(_address);\r\n    }\r\n    function _isController(address _address)\r\n        internal view\r\n        returns (bool allowed)\r\n    {\r\n        allowed = _controllers[_address];\r\n    }\r\n\r\n    /**\r\n     * @dev Remove the sender address from the list of controllers\r\n     */\r\n    function relinquishControl() external override onlyController {\r\n        _relinquishControl();\r\n    }\r\n    function _relinquishControl() internal onlyController{\r\n        delete _controllers[msg.sender];\r\n    }\r\n}\r\n"
    },
    "src/utilities/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../libraries/LibDiamond.sol\";\n\ncontract Modifiers {\n\n    modifier onlyOwner() {\n        require(LibDiamond.contractOwner() == msg.sender || address(this) == msg.sender,\n            \"not authorized to call function\");\n        _;\n    }\n\n    // function owner() public view returns (address) {\n    //     return LibDiamond.contractOwner();\n    // }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}