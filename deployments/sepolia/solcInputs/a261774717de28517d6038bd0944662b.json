{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Receiver.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\t/// @solidity memory-safe-assembly\n\t\tassembly {\n\t\t\tpop(staticcall(gas(), consoleAddress, add(payload, 32), mload(payload), 0, 0))\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "src/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport \"./interfaces/IERC721Enumerable.sol\";\n\nimport \"./libraries/DiamondLib.sol\";\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { DiamondLib } from \"./libraries/DiamondLib.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport { IDiamondLoupe } from \"./interfaces/IDiamondLoupe.sol\";\nimport { DiamondSettings } from \"./interfaces/IDiamond.sol\";\nimport { IERC173 } from \"./interfaces/IERC173.sol\";\n\ncontract Diamond is IERC165, IDiamondCut, IDiamondLoupe, Initializable, IERC173 {\n\n\n    function initialize(\n        address _owner, \n        DiamondSettings memory params,\n        IDiamondCut.FacetCut[] memory _facets,\n        address diamondInit,\n        bytes calldata _calldata\n    ) public initializer {\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC165).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC173).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC721).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC721Metadata).interfaceId] = true;\n\n        // initialize the diamond\n        LibDiamond.diamondCut(_facets, diamondInit, _calldata);\n\n        // set the symbol and name of the diamond\n        DiamondLib.diamondStorage().diamondContract.settings.owner = _owner;\n        DiamondLib.diamondStorage().diamondContract.metadata['symbol'] = params.symbol;\n        DiamondLib.diamondStorage().diamondContract.metadata['name'] = params.name;\n\n        IERC173(address(this)).transferOwnership(params.owner);\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        IDiamondCut.FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external override view returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory facetFunctionSelectors_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return type(IERC165).interfaceId == _interfaceId \n            || type(IERC721).interfaceId == _interfaceId \n            || type(IERC721Metadata).interfaceId == _interfaceId \n            || type(IERC721Enumerable).interfaceId == _interfaceId \n            || ds.supportedInterfaces[_interfaceId];\n    }\n\n    /// @notice transfer ownership to new contract\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    /// @notice get a address to the owner of the contract\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }    \n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/DiamondFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"./Diamond.sol\";\n\nimport \"./libraries/DiamondLib.sol\";\nimport \"./libraries/DiamondFactoryLib.sol\";\n\nimport \"./interfaces/IDiamondFactory.sol\";\nimport \"./interfaces/IMetadata.sol\";\nimport \"./interfaces/IControllable.sol\";\n\nimport \"./utilities/Controllable.sol\";\n\n/// @title Diamond Factory\n/// @notice This contract is used to create new Diamond contracts.\ncontract DiamondFactory is Initializable, Controllable {\n\n    using DiamondFactoryLib for DiamondFactoryStorage;\n\n    event DiamondCreated(\n        address indexed factory,\n        string indexed symbol,\n        DiamondSettings settings\n    );\n\n    event DiamondAdd(\n        address indexed factory,\n        string indexed symbol,\n        address indexed diamond\n    );\n\n    event DiamondRemoved(\n        address indexed factory,\n        string indexed symbol,\n        address indexed diamond\n    );\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /// @notice initiiate the factory\n    /// @param initData the address of the diamond init contract\n    function initialize(DiamondFactoryInit memory initData) public initializer {\n        DiamondFactoryLib.diamondFactoryStorage()._addFacetSet(\n            initData.setName,\n            initData.facetAddresses\n        );\n        DiamondFactoryLib\n            .diamondFactoryStorage()\n            .contractData\n            .defaultFacetSet = initData.setName;\n    }\n\n    /// @notice get the facets for the diamond\n    function getFacets(string memory facetSet)\n        external\n        view\n        returns (IDiamondCut.FacetCut[] memory)\n    {\n        return\n            DiamondFactoryLib.diamondFactoryStorage().contractData.facetsToAdd[\n                facetSet\n            ];\n    }\n\n    /// @notice set a template facet on this factory\n    /// @param idx the index of the facet to set\n    /// @param facetAddress the facet to set\n    function setFacet(\n        string memory facetSet,\n        uint256 idx,\n        IDiamondCut.FacetCut memory facetAddress\n    ) external onlyController {\n        DiamondFactoryLib.diamondFactoryStorage()._setFacet(\n            facetSet,\n            idx,\n            facetAddress\n        );\n    }\n\n    /// @notice set a number of template facets on this factory\n    /// @param facetSet the index of the facet to set\n    /// @param facetAddress the facet to set\n    function setFacets(\n        string memory facetSet,\n        IDiamondCut.FacetCut[] memory facetAddress\n    ) external onlyController {\n        DiamondFactoryLib.diamondFactoryStorage()._addFacetSet(\n            facetSet,\n            facetAddress\n        );\n    }\n\n    /// @notice remote a facet set from the factory\n    /// @param facetSet the facet set to remove\n    function removeFacets(string memory facetSet) external onlyController {\n        delete DiamondFactoryLib\n            .diamondFactoryStorage()\n            .contractData\n            .facetsToAdd[facetSet];\n    }\n\n    /// @notice get the address of the diamond\n    /// @param symbol the symbol of the diamond\n    /// @return the address of the diamond\n    function getDiamondAddress(string memory symbol)\n        public\n        view\n        returns (address)\n    {\n        return\n            DiamondFactoryLib.diamondFactoryStorage()._getDiamondAddress(\n                address(this),\n                symbol,\n                type(Diamond).creationCode\n            );\n    }\n\n    /// @notice create a new diamond token with the given symbol\n    /// @param params diamond init parameters\n    /// @param diamondInit the diamond init contract\n    /// @param _calldata the calldata to pass to the diamond init contract\n    function create(\n        DiamondSettings memory params,\n        address diamondInit,\n        bytes calldata _calldata,\n        IDiamondCut.FacetCut[] memory facets\n    ) public onlyController returns (address payable diamondAddress) {\n        // get the factory storage context, error if token already exists\n        require(\n            DiamondFactoryLib\n                .diamondFactoryStorage()\n                .contractData\n                .diamondAddresses[params.symbol] == address(0),\n            \"exists\"\n        );\n        diamondAddress = DiamondFactoryLib.diamondFactoryStorage().create(\n            address(this),\n            params,\n            diamondInit,\n            _calldata,\n            type(Diamond).creationCode,\n            facets\n        );\n        emit DiamondCreated(address(this), params.symbol, params);\n    }\n\n    /// @notice create a new diamond token with the given symbol\n    /// @param params diamond init parameters\n    /// @param diamondInit the diamond init contract\n    /// @param _calldata the calldata to pass to the diamond init contract\n    function createFromSet(\n        DiamondSettings memory params,\n        address diamondInit,\n        bytes calldata _calldata,\n        string memory facets\n    ) public onlyController returns (address payable diamondAddress) {\n        // get the factory storage context, error if token already exists\n        require(\n            DiamondFactoryLib\n                .diamondFactoryStorage()\n                .contractData\n                .diamondAddresses[params.symbol] == address(0),\n            \"exists\"\n        );\n        diamondAddress = DiamondFactoryLib.diamondFactoryStorage().createFromSet(\n            address(this),\n            params,\n            diamondInit,\n            _calldata,\n            type(Diamond).creationCode,\n            facets\n        );\n        emit DiamondCreated(address(this), params.symbol, params);\n    }\n\n    /// @notice add an existing diamong to the factory. it will then be returned by the getDiamondAddress function\n    /// @param symbol the symbol of the diamond\n    /// @param diamondAddress the address of the diamond\n    function add(string memory symbol, address payable diamondAddress)\n        public\n        onlyController\n    {\n        // get the factory storage context, error if token already exists\n        require(\n            DiamondFactoryLib\n                .diamondFactoryStorage()\n                .contractData\n                .diamondAddresses[symbol] == address(0),\n            \"exists\"\n        );\n        DiamondFactoryLib.diamondFactoryStorage().add(symbol, diamondAddress);\n        emit DiamondAdd(address(this), symbol, diamondAddress);\n    }\n\n    /// @notice remove a diamond from this factory\n    /// @param symbol the symbol of the diamond to remove\n    function remove(string memory symbol) public onlyController {\n        DiamondFactoryLib.diamondFactoryStorage().remove(symbol);\n        emit DiamondRemoved(\n            address(this),\n            symbol,\n            DiamondFactoryLib\n                .diamondFactoryStorage()\n                .contractData\n                .diamondAddresses[symbol]\n        );\n    }\n\n    /// @notice check if the token exists\n    /// @param symbol the symbol of the diamond to check\n    function exists(string memory symbol) public view returns (bool) {\n        return\n            DiamondFactoryLib\n                .diamondFactoryStorage()\n                .contractData\n                .diamondAddresses[symbol] != address(0);\n    }\n\n    /// @notice get all the symbols from the factory\n    /// @return the symbols\n    function symbols() public view returns (string[] memory) {\n        return\n            DiamondFactoryLib\n                .diamondFactoryStorage()\n                .contractData\n                .diamondSymbols;\n    }\n}\n"
    },
    "src/facets/ClaimTopicsRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IClaimTopicsRegistry.sol\";\nimport \"../libraries/ClaimTopicLib.sol\";\n\ncontract ClaimTopicsRegistryFacet is IClaimTopicsRegistry {\n\n    using ClaimTopicLib for ClaimTopicContract;\n\n    modifier onlyOwner() {\n        require(msg.sender == ClaimTopicLib.claimTopicStorage().owner, \"Caller is not the owner\");\n        _;\n    }\n\n    constructor() {\n        ClaimTopicStorage storage _contract = ClaimTopicLib.claimTopicStorage();\n        _contract.owner = msg.sender;\n    }\n\n    function addClaimTopic(uint256 _claimTopic) external override onlyOwner {\n        ClaimTopicContract storage _contract = ClaimTopicLib.claimTopicStorage()._contract;\n        _contract.addClaimTopic(_claimTopic, msg.sender);\n    }\n\n    function removeClaimTopic(uint256 _claimTopic) external override onlyOwner {\n        ClaimTopicContract storage _contract = ClaimTopicLib.claimTopicStorage()._contract;\n        _contract.removeClaimTopic(_claimTopic, msg.sender);\n    }\n\n    function getClaimTopics() external view override returns (uint256[] memory) {\n        ClaimTopicContract storage _contract = ClaimTopicLib.claimTopicStorage()._contract;\n        return _contract.getClaimTopics();\n    }\n\n    function transferOwnershipOnClaimTopicsRegistryContract(address _newOwner) external override\n    onlyOwner {\n        require(_newOwner != address(0), \"New owner is the zero address\");\n        ClaimTopicStorage storage _contract = ClaimTopicLib.claimTopicStorage();\n        _contract.owner = _newOwner;\n    }\n}"
    },
    "src/facets/IdentityRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IIdentityRegistry.sol\";\nimport \"../libraries/IdentityLib.sol\";\nimport \"../libraries/TrustedIssuerLib.sol\";\nimport \"../utilities/Modifiers.sol\";\n\nimport \"../interfaces/ITrustedIssuersRegistry.sol\";\nimport \"../interfaces/IClaimTopicsRegistry.sol\";\n\nimport { IIdentityRegistry, IIdentity } from \"../interfaces/IIdentityRegistry.sol\";\n\ncontract IdentityRegistryFacet is IIdentityRegistry, Modifiers {\n\tusing IdentityLib for IdentityContract;\n    using TrustedIssuerLib for TrustedIssuerContract;\n\n\taddress private issuersRegistry;\n\taddress private topicsRegistry;\n\n\tevent ContractAddressesSet(address indexed _trustedIssuersRegistry, address indexed _claimTopicsRegistry);\n\n\tmodifier isTrustedIssuer() {\n\t\trequire(ITrustedIssuersRegistry(issuersRegistry).isTrustedIssuer(msg.sender), \"Not trusted issuer\");\n\t\t_;\n\t}\n\n\tfunction setClaimTopicsRegistry(address _claimTopicsRegistry) external onlyOwner {\n\t\ttopicsRegistry = address(_claimTopicsRegistry);\n\t\temit ContractAddressesSet(address(issuersRegistry), _claimTopicsRegistry);\n\t}\n\n\tfunction setTrustedIssuersRegistry(address _trustedIssuersRegistry) external onlyOwner {\n\t\tissuersRegistry = address(_trustedIssuersRegistry);\n\t\temit ContractAddressesSet(_trustedIssuersRegistry, address(topicsRegistry));\n\t}\n\n    function _addIdentity(address _identity, IIdentity identityData) internal {\n        IdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n        Identity storage idObj = _contract._getIdentity(_identity);\n        require(idObj.identityData == IIdentity(address(0)), \"Identity already exists\");\n        idObj.identityData = identityData;\n        _contract.identityOwners.push(_identity);\n        emit IdentityAdded(_identity, identityData);\n    }\n\n\tfunction addIdentity(address _identity, IIdentity identityData) external override {\n       _addIdentity(_identity, identityData);\n    }\n\n\tfunction removeIdentity(address _identity) external override {\n        IdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n        Identity storage idObj = _contract._getIdentity(_identity);\n        require(idObj.identityData != IIdentity(address(0)), \"Identity does not exist\");\n        delete _contract.identities[_identity];\n        emit IdentityRemoved(_identity, idObj.identityData);\n    }\n\n\tfunction identity(address _userAddress) external view override returns (IIdentity) {\n        IdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n        return _contract._getIdentity(_userAddress).identityData;\n    }\n\n\tfunction batchAddIdentity(address[] calldata _identities, IIdentity[] calldata identityDatas) external override {\n        require(_identities.length == identityDatas.length, \"Arrays length mismatch\");\n        for (uint256 i = 0; i < _identities.length; i++) {\n            _addIdentity(_identities[i], identityDatas[i]);\n        }\n\t}\n\n\tfunction addClaim(address _identity, uint256 _claimTopic, bytes calldata _claim) external override isTrustedIssuer {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\tIdentity storage idObj = _contract._getIdentity(_identity);\n\t\trequire(!idObj.claimTopics[_claimTopic], \"Claim already exists\");\n\t\tidObj.claims[_claimTopic] = _claim;\n\t\tidObj.claimTopics[_claimTopic] = true;\n\t\temit ClaimAdded(_identity, _claimTopic, _claim);\n\t}\n\n\tfunction removeClaim(address _identity, uint256 _claimTopic) external override isTrustedIssuer {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\tIdentity storage idObj = _contract._getIdentity(_identity);\n\t\trequire(idObj.claimTopics[_claimTopic], \"Claim does not exist\");\n\t\tdelete idObj.claims[_claimTopic];\n\t\tdelete idObj.claimTopics[_claimTopic];\n\t\temit ClaimRemoved(_identity, _claimTopic);\n\t}\n\n\tfunction contains(address _userAddress) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract._getIdentity(_userAddress).identityData != IIdentity(address(0));\n\t}\n\n\tfunction isVerified(address _userAddress) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract._getIdentity(_userAddress).identityData.isVerified();\n\t}\n\n\tfunction getRegistryUsers() external view override returns (address[] memory) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract.identityOwners;\n\t}\n\n\tfunction isRegistryUser(address _registryUser) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract._getIdentity(_registryUser).identityData != IIdentity(address(0));\n\t}\n\n\tfunction getClaims(address _registryUser) external view override returns (uint256[] memory) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\tIdentity storage idObj = _contract._getIdentity(_registryUser);\n\t\tuint256[] memory claims = new uint256[](idObj.identityData.getClaimTopics().length);\n\t\tfor (uint256 i = 0; i < idObj.identityData.getClaimTopics().length; i++) {\n\t\t\tclaims[i] = idObj.identityData.getClaimTopics()[i];\n\t\t}\n\t\treturn claims;\n\t}\n\n\tfunction getClaim(address _registryUser, uint256 _claimTopic) external view override returns (bytes memory) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\tIdentity storage idObj = _contract._getIdentity(_registryUser);\n\t\treturn idObj.claims[_claimTopic];\n\t}\n\n\tfunction hasClaim(address _registryUser, uint256 _claimTopic) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\tIdentity storage idObj = _contract._getIdentity(_registryUser);\n\t\treturn idObj.claimTopics[_claimTopic];\n\t}\n\n\tfunction getOnchainIDFromWallet(address _userAddress) external view override returns (bytes32) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract.addressToOnchainID[_userAddress];\n\t}\n\n\tfunction walletLinked(bytes32) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract.identityAddresses.length > 0;\n\t}\n\n\tfunction unlinkWallet(bytes32 _onchainID) external override {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\trequire(_contract.identityAddresses.length > 0, \"No linked wallet\");\n\t\taddress _walletAddress = _contract.identityAddresses[_contract.identityAddresses.length - 1];\n\t\t_contract.addressToOnchainID[_walletAddress] = bytes32(0);\n\t\t_contract.identityAddresses.pop();\n\t\temit WalletUnlinked(_walletAddress, _onchainID);\n\t}\n\n\tfunction unlinkWalletAddress(address _walletAddress) external override {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\trequire(_contract.identityAddresses.length > 0, \"No linked wallet\");\n\t\tbytes32 _onchainID = _contract.addressToOnchainID[_walletAddress];\n\t\t_contract.addressToOnchainID[_walletAddress] = bytes32(0);\n\t\t_contract.identityAddresses.pop();\n\t\temit WalletUnlinked(_walletAddress, _onchainID);\n\t}\n\n\tfunction walletAddressLinked(address _walletAddress) external view override returns (bool) {\n\t\tIdentityContract storage _contract = IdentityLib.identityStorage().identityContract;\n\t\treturn _contract.addressToOnchainID[_walletAddress] != bytes32(0);\n\t}\n\n}\n"
    },
    "src/facets/SVGTemplatesFacet.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ISVG.sol\";\nimport \"../interfaces/IStrings.sol\";\n\nimport \"../libraries/StringsLib.sol\";\nimport \"../libraries/SVGTemplatesLib.sol\";\n\nimport \"../utilities/Modifiers.sol\";\n\n/// @title SVGTemplatesFacet\n/// @notice This contract is used to create and manage SVG templates\ncontract SVGTemplatesFacet is Modifiers {\n\n    using SVGTemplatesLib for SVGTemplatesContract;\n\n    // @notice an SVG templte has been created\n    event SVGTemplateCreated(string name, address template);\n\n    /// @notice set the svg manager\n    /// @param _manager the address of the svg manager\n    function setSVGManager(address _manager) external onlyOwner {\n        SVGTemplatesLib.svgStorage().svgManager = _manager;\n    }\n\n    /// @notice get all the svgs stored in the contract\n    /// @return the names of the svgs\n    function svgs() external view returns (string[] memory) {\n        address svgManager = SVGTemplatesLib.svgStorage().svgManager;\n        return ISVGTemplate(svgManager).svgs();\n    }\n\n    /// @notice get the svg address of the given svg name. does not mean the file exists.\n    /// @param _name the name of the svg\n    /// @return _svgAddress the address of the svg\n    function svgAddress(string memory _name) external view returns (address _svgAddress) {\n        address svgManager = SVGTemplatesLib.svgStorage().svgManager;\n        _svgAddress = ISVGTemplate(svgManager).svgAddress(_name);\n    }\n\n    /// @notice get the svg data of the given svg name as a string\n    /// @param _name the name of the svg\n    /// @return data_ the svg data as a string\n    function svgString(string memory _name) external view returns (string memory data_) {\n        address svgManager = SVGTemplatesLib.svgStorage().svgManager;\n        data_ = ISVGTemplate(svgManager).svgString(_name);\n    }\n    \n    /// @notice add a new svg template and return the template address to the caller\n    /// @param _name the name of the svg\n    /// @param _tplAddress the svg data as a string\n    function createSVG(string memory _name) external onlyOwner returns(address _tplAddress) {\n         address svgManager = SVGTemplatesLib.svgStorage().svgManager;\n        _tplAddress = ISVGTemplate(svgManager).createSVG(msg.sender, _name);\n    }\n\n}  \n"
    },
    "src/facets/TrustedIsssuersRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IClaimIssuer } from \"../interfaces/IClaimIssuer.sol\";\nimport { ITrustedIssuersRegistry } from \"../interfaces/ITrustedIssuersRegistry.sol\";\n\nimport \"../libraries/TrustedIssuerLib.sol\";\n\ncontract TrustedIssuersRegistryFacet is ITrustedIssuersRegistry {\n\tusing TrustedIssuerLib for TrustedIssuerContract;\n\n\taddress public owner;\n\tIClaimIssuer[] public trustedIssuers;\n\tmapping(IClaimIssuer => uint[]) public trustedIssuerClaimTopics;\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"Caller is not the owner\");\n\t\t_;\n\t}\n\n\tconstructor() {\n\t\towner = msg.sender;\n\t}\n\n\tfunction getTrustedIssuer(address issuerAddress) external view returns (TrustedIssuer memory) {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\treturn _contract._getTrustedIssuer(issuerAddress);\n\t}\n\n\tfunction setTrustedIssuer(address issuerAddress, TrustedIssuer memory trustedIssuer) external {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\t_contract._setTrustedIssuer(issuerAddress, trustedIssuer);\n\t}\n\n\tfunction addTrustedIssuer(address _trustedIssuer, uint[] calldata _claimTopics) external onlyOwner {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\t_contract._addTrustedIssuer(_trustedIssuer, _claimTopics);\n\t}\n\n\tfunction removeTrustedIssuer(address _trustedIssuer) external onlyOwner {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\t_contract.removeTrustedIssuer(_trustedIssuer);\n\t}\n\n\tfunction updateIssuerClaimTopics(address _trustedIssuer, uint[] calldata _claimTopics) external {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\t_contract.updateIssuerClaimTopics(_trustedIssuer, _claimTopics);\n\t}\n\n\tfunction getTrustedIssuers() external view override returns (TrustedIssuer[] memory) {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\treturn _contract.getTrustedIssuers();\n\t}\n\n\tfunction isTrustedIssuer(address _issuer) external view override returns (bool) {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\treturn TrustedIssuerLib.isTrustedIssuer(_issuer);\n\t}\n\n\tfunction getTrustedIssuerClaimTopics(address _trustedIssuer) external view returns (uint[] memory) {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\treturn TrustedIssuerLib.getTrustedIssuerClaimTopics(_trustedIssuer);\n\t}\n\n\tfunction hasClaimTopic(address _issuer, uint _claimTopic) external view override returns (bool) {\n\t\tTrustedIssuerContract storage _contract = TrustedIssuerLib.trustedIssuerStorage().trustedIssuerContract;\n\t\treturn TrustedIssuerLib.hasClaimTopic(_issuer, _claimTopic);\n\t}\n}\n"
    },
    "src/identity/Identity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IIdentity } from \"../interfaces/IIdentity.sol\";\n\n/// @title Identity\n/// @notice This contract represents an identity of a user\n/// @dev This contract is used to store the claims of a user\ncontract Identity is IIdentity {\n\t\n\tmapping(bytes32 => Key) keys;\n\tmapping(uint256 => bytes32[]) keysByPurpose;\n\n\tstruct Key {\n\t\tuint256[] purposes;\n\t\tuint256 keyType;\n\t\tbytes32 key;\n\t}\n\n\tfunction addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external override {\n\t\trequire(keys[_key].key != _key, \"Key already exists\");\n\n\t\tkeys[_key].key = _key;\n\t\tkeys[_key].purposes.push(_purpose);\n\t\tkeys[_key].keyType = _keyType;\n\n\t\tkeysByPurpose[_purpose].push(_key);\n\n\t\temit KeyAdded(_key, _purpose, _keyType);\n\t}\n\n\tfunction removeKey(bytes32 _key, uint256 _purpose) external override {\n\t\trequire(keys[_key].key == _key, \"No such key\");\n\t\tfor (uint i = 0; i < keys[_key].purposes.length; i++) {\n\t\t\tif (keys[_key].purposes[i] == _purpose) {\n\t\t\t\tdelete keys[_key].purposes[i];\n\t\t\t}\n\t\t}\n\n\t\temit KeyRemoved(_key, _purpose, keys[_key].keyType);\n\n\t\tdelete keys[_key];\n\t}\n\n\tfunction getKey(\n\t\tbytes32 _key\n\t) external view override returns (uint256[] memory purposes, uint256 keyType, bytes32 key) {\n\t\treturn (keys[_key].purposes, keys[_key].keyType, keys[_key].key);\n\t}\n\n\tfunction getKeyPurposes(bytes32 _key) external view override returns (uint256[] memory _purposes) {\n\t\treturn (keys[_key].purposes);\n\t}\n\n\tfunction getKeysByPurpose(uint256 _purpose) external view override returns (bytes32[] memory _keys) {\n\t\treturn (keysByPurpose[_purpose]);\n\t}\n\n\tfunction _keyHasPurpose(bytes32 _key, uint256 _purpose) internal view returns (bool exists) {\n\t\tif (keys[_key].key == 0) return false;\n\t\tfor (uint i = 0; i < keys[_key].purposes.length; i++) {\n\t\t\tif (keys[_key].purposes[i] == _purpose) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists) {\n\t\treturn _keyHasPurpose(_key, _purpose);\n\t}\n\n\tfunction execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId) {\n\t\trequire(_keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have rights\");\n\t\t(bool success, ) = _to.call{value: _value}(_data);\n\t\tif (success) {\n\t\t\temit Executed(executionId, _to, _value, _data);\n\t\t} else {\n\t\t\temit ExecutionFailed(executionId, _to, _value, _data);\n\t\t}\n\t\treturn executionId;\n\t}\n\n\tfunction approve(uint256 _id, bool _approve) external override {\n\t\trequire(_keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have rights\");\n\t\tif (_approve) {\n\t\t\temit Approved(_id, true);\n\t\t} else {\n\t\t\temit Approved(_id, false);\n\t\t}\n\t}\n\n\tstruct Claim {\n\t\tuint256 topic;\n\t\tuint256 scheme;\n\t\taddress issuer;\n\t\tbytes signature;\n\t\tbytes data;\n\t\tstring uri;\n\t}\n\n\tmapping(bytes32 => Claim) internal claims;\n\tbytes32[] internal claimIds;\n\n\tmapping(uint256 => bytes32[]) internal claimsByTopic;\n\tbytes32[] internal claimTopics;\n\n\tfunction getClaim(bytes32 _claimId)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (\n\t\t\tuint256 topic,\n\t\t\tuint256 scheme,\n\t\t\taddress issuer,\n\t\t\tbytes memory signature,\n\t\t\tbytes memory data,\n\t\t\tstring memory uri\n\t\t) {\n\t\tClaim storage claim = claims[_claimId];\n\t\treturn (claim.topic, claim.scheme, claim.issuer, claim.signature, claim.data, claim.uri);\n\t}\n\n\tfunction getClaimIdsByTopic(uint256 _topic) external view override returns (bytes32[] memory claimIds_) {\n\t\tclaimIds_ = claimsByTopic[_topic];\n\t}\n\n\tfunction addClaim(\n\t\tuint256 _topic,\n\t\tuint256 _scheme,\n\t\taddress _issuer,\n\t\tbytes memory _signature,\n\t\tbytes memory _data,\n\t\tstring memory _uri\n\t) external override returns (uint256 claimRequestId) {\n\t\tbytes32 claimId = keccak256(abi.encodePacked(_issuer, _topic));\n\n\t\tClaim storage claim = claims[claimId];\n\t\tclaim.topic = _topic;\n\t\tclaim.scheme = _scheme;\n\t\tclaim.issuer = _issuer;\n\t\tclaim.signature = _signature;\n\t\tclaim.data = _data;\n\t\tclaim.uri = _uri;\n\n\t\tclaimsByTopic[_topic].push(claimId);\n\t\tclaimTopics.push(claimId);\n\n\t\tclaims[claimId] = claim;\n\t\tclaimIds.push(claimId);\n\n\t\temit ClaimAdded(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n\n\t\treturn _topic;\n\t}\n\n\tfunction changeClaim(\n\t\tbytes32,\n\t\tuint256,\n\t\tuint256,\n\t\taddress,\n\t\tbytes memory,\n\t\tbytes memory,\n\t\tstring memory\n\t) external pure override returns (bool) {\n\t\trequire(false, \"Not implemented\");\n\t}\n\n\tfunction removeClaim(bytes32 _claimId) external override returns (bool success) {\n\t\tClaim storage claim = claims[_claimId];\n\t\trequire(claim.issuer != address(0), \"Claim does not exist\");\n\t\tdelete claims[_claimId];\n\t\temit ClaimRemoved(_claimId, claim.topic, claim.scheme, claim.issuer, claim.signature, claim.data, claim.uri);\n\t\treturn true;\n\t}\n\n\tfunction supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n\t\treturn interfaceId == type(IIdentity).interfaceId;\n\t}\n\n\tfunction getExecution(\n\t\tuint256 _id\n\t)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (address to, uint256 value, bytes memory data, bool approved, uint256 executionType)\n\t{}\n\n\t function getClaimTopics() external view override returns (uint256[] memory) {\n\t\t uint256[] memory _claimTopics = new uint256[](claimTopics.length);\n\t\t for (uint256 i = 0; i < claimTopics.length; i++) {\n\t\t\t _claimTopics[i] = claims[claimTopics[i]].topic;\n\t\t }\n\t\t return _claimTopics;\n\t }\n\n\t function isVerified() external view returns (bool) {}\n}"
    },
    "src/interfaces/IAttribute.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\nenum AttributeType {\r\n    Unknown,\r\n    String ,\r\n    Bytes32,\r\n    Uint256,\r\n    Uint8,\r\n    Uint256Array,\r\n    Uint8Array\r\n}\r\n\r\nstruct Attribute {\r\n    string key;\r\n    AttributeType attributeType;\r\n    string value;\r\n}\r\n\r\n// attribute storage\r\nstruct AttributeContract {\r\n    mapping(uint256 => bool)  burnedIds;\r\n    mapping(uint256 => mapping(string => Attribute))  attributes;\r\n    mapping(uint256 => string[]) attributeKeys;\r\n    mapping(uint256 =>  mapping(string => uint256)) attributeKeysIndexes;\r\n}\r\n\r\n\r\n/// @notice a pool of tokens that users can deposit into and withdraw from\r\ninterface IAttribute {\r\n    /// @notice get an attribute for a tokenid keyed by string\r\n    function getAttribute(\r\n        uint256 id,\r\n        string memory key\r\n    ) external view returns (Attribute calldata _attrib);\r\n}\r\n"
    },
    "src/interfaces/IClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IIdentity.sol\";\n\nstruct Claim {\n    uint256 topic;\n    uint256 scheme;\n    address issuer;\n    bytes signature;\n    bytes data;\n    string uri;\n    bool isRemoved;\n}\n\ninterface IClaimIssuer is IIdentity {\n\n    event ClaimRevoked(bytes indexed signature);\n\n    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);\n    function revokeClaimBySignature(bytes calldata signature) external;\n    function isClaimRevoked(bytes calldata _sig) external view returns (bool);\n    function isClaimValid(\n        IIdentity _identity,\n        uint256 claimTopic,\n        bytes calldata sig,\n        bytes calldata data)\n    external view returns (bool);\n    function getRecoveredAddress(bytes calldata sig, bytes32 dataHash) external pure returns (address);\n    \n}"
    },
    "src/interfaces/IClaimTopicsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IClaimTopicsRegistry {\n\n    // events\n    event ClaimTopicAdded(uint256 indexed claimTopic);\n    event ClaimTopicRemoved(uint256 indexed claimTopic);\n\n    // functions\n    // setters\n    function addClaimTopic(uint256 _claimTopic) external;\n    function removeClaimTopic(uint256 _claimTopic) external;\n\n    // getter\n    function getClaimTopics() external view returns (uint256[] memory);\n\n    // role setter\n    function transferOwnershipOnClaimTopicsRegistryContract(address _newOwner) external;\n}"
    },
    "src/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice a controllable contract interface. allows for controllers to perform privileged actions. controllera can other controllers and remove themselves.\r\ninterface IControllable {\r\n\r\n    /// @notice emitted when a controller is added.\r\n    event ControllerAdded(\r\n        address indexed contractAddress,\r\n        address indexed controllerAddress\r\n    );\r\n\r\n    /// @notice emitted when a controller is removed.\r\n    event ControllerRemoved(\r\n        address indexed contractAddress,\r\n        address indexed controllerAddress\r\n    );\r\n\r\n    /// @notice adds a controller.\r\n    /// @param controller the controller to add.\r\n    function addController(address controller) external;\r\n\r\n    /// @notice removes a controller.\r\n    /// @param controller the address to check\r\n    /// @return true if the address is a controller\r\n    function isController(address controller) external view returns (bool);\r\n\r\n    /// @notice remove ourselves from the list of controllers.\r\n    function relinquishControl() external;\r\n}\r\n"
    },
    "src/interfaces/IDiamond.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n\nstruct DiamondSettings {\n  address owner;\n  address factory;\n  address svgManager;\n  string symbol;\n  string name;\n}\n\nstruct DiamondContract {\n  DiamondSettings settings;\n  mapping(string=>string) metadata;\n}\n\nstruct DiamondStorage {\n  DiamondContract diamondContract;\n}\n"
    },
    "src/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n"
    },
    "src/interfaces/IDiamondFacetInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./IDiamondCut.sol\";\nimport \"./IERC165.sol\";\n\ninterface IDiamondFacetInit is IERC165 {\n    function initializeFacet(\n        address _owner, \n        IDiamondCut.FacetCut memory _facet,\n        bytes calldata _calldata) external;\n}\n"
    },
    "src/interfaces/IDiamondFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport { IDiamondCut } from \"./IDiamondCut.sol\";\n\nstruct DiamondFactoryInit {\n    string setName;\n    IDiamondCut.FacetCut[] facetAddresses;\n}\n\nstruct DiamondFactoryContract {\n    string[] diamondSymbols;\n    mapping(string => address) diamondAddresses;\n    mapping(string => IDiamondCut.FacetCut[]) facetsToAdd;\n    string defaultFacetSet;\n    address diamondInit_;\n    bytes calldata_;\n}\n\n\nstruct DiamondFactoryStorage {\n  DiamondFactoryContract contractData;\n}\n"
    },
    "src/interfaces/IDiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./IDiamondCut.sol\";\n\ninterface IDiamondInit {\n    function initialize(\n        address _owner, \n        IDiamondCut.FacetCut[] memory _facets,\n        address _init,\n        bytes calldata _calldata) external;\n}\n"
    },
    "src/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n"
    },
    "src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "src/interfaces/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/* solhint-disable indent */\n\n// Compiler will pack this into a single 256bit word.\nstruct TokenOwnership {\n    address addr; // The address of the owner.\n    uint64 startTimestamp; // Keeps track of the start time of ownership with minimal overhead for tokenomics.\n    bool burned; // Whether the token has been burned.\n}\n\n// Compiler will pack this into a single 256bit word.\nstruct AddressData {\n    \n    uint64 balance; // Realistically, 2**64-1 is more than enough.\n    uint64 numberMinted; // Keeps track of mint count with minimal overhead for tokenomics.\n    uint64 numberBurned; // Keeps track of burn count with minimal overhead for tokenomics.\n    // For miscellaneous variable(s) pertaining to the address\n    // (e.g. number of whitelist mint slots used).\n    // If there are multiple variables, please pack them into a uint64.\n    uint64 aux;\n}\n\nstruct ERC721AContract {\n    // The tokenId of the next token to be minted.\n    uint256 _currentIndex;\n\n    // The number of tokens burned.\n    uint256 _burnCounter;\n\n    // Token name\n    string _name;\n\n    // Token symbol\n    string _symbol;\n\n    // the base uri\n    string __uri;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) _operatorApprovals;\n}\n"
    },
    "src/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nstruct ERC721EnumerableContract {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) _allTokensIndex;\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "src/interfaces/IERC721Mint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// implemented by erc1155 tokens to allow mminting\ninterface IERC721Mint {\n\n    /// @notice mint tokens of specified amount to the specified address\n    function mint(\n        uint256 quantity,\n        bytes calldata data\n    ) external returns (uint256 tokenId);\n\n    /// @notice mint tokens of specified amount to the specified address\n    function mintTo(\n        address receiver,\n        uint256 quantity,\n        bytes calldata data\n    ) external returns (uint256 tokenId);\n\n}\n"
    },
    "src/interfaces/IERC734.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"./IERC165.sol\";\n\ninterface IERC734 is IERC165 {\n    // events\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(\n        uint256 indexed executionId,\n        address indexed to,\n        uint256 indexed value,\n        bytes data\n    );\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    // functions\n    // setters\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external;\n    function removeKey(bytes32 _key, uint256 _purpose) external;\n    function approve(uint256 _id, bool _approve) external;\n\n    // getters\n    function getKey(bytes32 _key) external view returns(uint256[] memory purposes, uint256 keyType, bytes32 key);\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory);\n    function getKeysByPurpose(uint256 _purpose) external view returns(bytes32[] memory);\n    function getExecution(uint256 _id) external view returns(address to, uint256 value, bytes memory data, bool approved, uint256 executionType);\n}\n"
    },
    "src/interfaces/IERC735.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IERC735 {\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n\n    function getClaim(bytes32 _claimId) external returns(uint256 topic, uint256 scheme, address issuer, bytes memory signature, bytes memory data, string memory uri);\n    function getClaimIdsByTopic(uint256 _topic) external returns(bytes32[] memory claimIds);\n    function addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) external returns (uint256 claimRequestId);\n    function changeClaim(bytes32 _claimId, uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) external returns (bool success);\n    function removeClaim(bytes32 _claimId) external returns (bool success);\n}"
    },
    "src/interfaces/IIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC734 } from \"./IERC734.sol\";\nimport { IERC735 } from \"./IERC735.sol\";\n\ninterface IIdentity is IERC734, IERC735 {\n    function isVerified() external view returns (bool);\n    function getClaimTopics() external view returns (uint256[] memory);\n}"
    },
    "src/interfaces/IIdentityRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport { IIdentity } from \"./IIdentity.sol\";\n\ninterface IIdentityRegistry {\n    // events\n    event IdentityAdded(address indexed _address, IIdentity identity);\n    event IdentityRemoved(address indexed _address, IIdentity identity);\n    event IdentityCountryUpdated(address indexed identity, uint16 indexed country);\n    event ClaimAdded(address indexed identity, uint256 indexed claimTopic, bytes claim);\n    event ClaimRemoved(address indexed identity, uint256 indexed claimTopic);\n    event WalletLinked(address indexed walletAddress, bytes32 indexed onchainID);\n    event WalletUnlinked(address indexed walletAddress, bytes32 indexed onchainID);\n\n    // functions\n    function addIdentity(address _identity, IIdentity identityData) external;\n    function batchAddIdentity(address[] calldata _identities, IIdentity[] calldata identityDatas) external;\n    function removeIdentity(address _identity) external;\n    function addClaim(address _identity, uint256 _claimTopic, bytes calldata _claim) external;\n    function removeClaim(address _identity, uint256 _claimTopic) external;\n\n    // registry consultation\n    function contains(address _userAddress) external view returns (bool);\n    function isVerified(address _userAddress) external view returns (bool);\n    function identity(address _userAddress) external view returns (IIdentity);\n\n    // getters\n    function getRegistryUsers() external view returns (address[] memory);\n    function isRegistryUser(address _registryUser) external view returns(bool);\n    function getClaims(address _registryUser) external view returns(uint256[] memory);\n    function getClaim(address _registryUser, uint256 _claimTopic) external view returns(bytes memory);\n    function hasClaim(address _registryUser, uint256 _claimTopic) external view returns(bool);\n\n    function getOnchainIDFromWallet(address _userAddress) external view returns (bytes32);\n    function walletLinked(bytes32 _onchainID) external view returns (bool);\n    function unlinkWallet(bytes32 _onchainID) external;\n    function unlinkWalletAddress(address _walletAddress) external;\n    function walletAddressLinked(address _walletAddress) external view returns (bool);\n}"
    },
    "src/interfaces/IMetadata.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n\n/* solhint-disable indent */\n\n// enum metadatasource\nenum MetadataSource {\n    EXTERNAL, INTERNAL\n}\n\nstruct Trait {\n    string displayType;\n    string key;\n    string value;\n}\n\nstruct MetadataContract {\n    string _name;\n    string _symbol;\n    string _description;\n    string _imageName;\n    string[] _imageColors;\n    string _externalUri;\n    MetadataSource _metadataSource;\n    string _baseUri;\n}\n"
    },
    "src/interfaces/IMultiPart.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n\n/* solhint-disable indent */\n\n\nstruct MultiPartContract {\n    string name_;\n    bytes[] data_;\n}\n"
    },
    "src/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRegistry {\n    function addIdentity(address _identity) external returns (bool success);\n    function removeIdentity(address _identity) external returns (bool success);\n    function checkIdentity(address _identity) external view returns (bool exists);\n}"
    },
    "src/interfaces/IRegistryUsersRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRegistryUsersRegistry {\n\n    // events\n    event RegistryUserAdded(address indexed registryUser);\n    event RegistryUserRemoved(address indexed registryUser);\n    event ClaimAdded(address indexed registryUser, uint256 indexed claimTopic, bytes claim);\n    event ClaimRemoved(address indexed registryUser, uint256 indexed claimTopic);\n\n    // functions\n    // setters\n    function addRegistryUser(address _registryUser) external;\n    function removeRegistryUser(address _registryUser) external;\n    function addClaim(address _registryUser, uint256 _claimTopic, bytes calldata _claim) external;\n    function removeClaim(address _registryUser, uint256 _claimTopic) external;\n\n    // getters\n    function getRegistryUsers() external view returns (address[] memory);\n    function isRegistryUser(address _registryUser) external view returns(bool);\n    function getClaims(address _registryUser) external view returns(uint256[] memory);\n    function getClaim(address _registryUser, uint256 _claimTopic) external view returns(bytes memory);\n    function hasClaim(address _registryUser, uint256 _claimTopic) external view returns(bool);\n\n}"
    },
    "src/interfaces/IStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nstruct Replacement {\n    string matchString;\n    string replaceString;\n}\n"
    },
    "src/interfaces/ISVG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../interfaces/IStrings.sol\";\n\nstruct SVGTemplatesContract {\n    mapping(string => address) _templates;\n    string[] _templateNames;\n}\n\ninterface ISVG {\n    function getSVG() external view returns (string memory);\n}\n\ninterface ISVGTemplate {\n    function createSVG(address sender, string memory _name) external returns (address _tplAddress);\n    function svgs() external view returns (string[] memory);\n    function svgName() external view returns (string memory _name);\n    function svgString(string memory name) external view returns (string memory _data);\n    function svgAddress(string memory name) external view returns (address _data);\n    function svgBytes() external view returns (bytes[] memory _data);\n    function clear() external;\n    function add(string memory _data) external returns (uint256 _index);\n    function addAll(string[] memory _data) external returns (uint256 _count);\n    function buildSVG(Replacement[] memory replacements) external view returns (string memory);\n}\n"
    },
    "src/interfaces/ISVGFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface ISVGFactory {\n    function templateAddress(string memory _name) external view returns (address);\n}\n"
    },
    "src/interfaces/IToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice the definition for a token.\r\nstruct TokenDefinition {\r\n    address token;\r\n    string name;\r\n    string symbol;\r\n    string description;\r\n    uint256 totalSupply;\r\n    string imageName;\r\n    string[] imagePalette;\r\n    string externalUrl;\r\n}\r\n\r\nenum TokenType {\r\n    ERC20,\r\n    ERC721,\r\n    ERC1155\r\n}"
    },
    "src/interfaces/ITrustedIssuersRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IClaimIssuer } from \"./IClaimIssuer.sol\";\n\nstruct TrustedIssuer {\n    address claimIssuer;\n    uint[] claimTopics;\n}\n\ninterface ITrustedIssuersRegistry {\n\n    // events\n    event TrustedIssuerAdded(address indexed trustedIssuer, uint[] claimTopics);\n    event TrustedIssuerRemoved(address indexed trustedIssuer);\n    event ClaimTopicsUpdated(address indexed trustedIssuer, uint[] claimTopics);\n\n    // functions\n    // setters\n    function addTrustedIssuer(address _trustedIssuer, uint[] calldata _claimTopics) external;\n    function removeTrustedIssuer(address _trustedIssuer) external;\n    function updateIssuerClaimTopics(address _trustedIssuer, uint[] calldata _claimTopics) external;\n\n    // getters\n    function getTrustedIssuers() external view returns (TrustedIssuer[] memory);\n    function isTrustedIssuer(address _issuer) external view returns(bool);\n    function getTrustedIssuerClaimTopics(address _trustedIssuer) external view returns(uint[] memory);\n    function hasClaimTopic(address _issuer, uint _claimTopic) external view returns(bool);\n\n}"
    },
    "src/libraries/AddressSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @notice Key sets with enumeration and delete. Uses mappings for random\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\n * fixed gas cost at any scale, O(1).\n * author: Rob Hitchens\n */\n\nlibrary AddressSet {\n    struct Set {\n        mapping(address => uint256) keyPointers;\n        address[] keyList;\n    }\n\n    /**\n     * @notice insert a key.\n     * @dev duplicate keys are not permitted.\n     * @param self storage pointer to a Set.\n     * @param key value to insert.\n     */\n    function insert(Set storage self, address key) public {\n        require(\n            !exists(self, key),\n            \"AddressSet: key already exists in the set.\"\n        );\n        self.keyList.push(key);\n        self.keyPointers[key] = self.keyList.length - 1;\n    }\n\n    /**\n     * @notice remove a key.\n     * @dev key to remove must exist.\n     * @param self storage pointer to a Set.\n     * @param key value to remove.\n     */\n    function remove(Set storage self, address key) public {\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\n        require(\n            exists(self, key),\n            \"AddressSet: key does not exist in the set.\"\n        );\n        if (!exists(self, key)) return;\n        uint256 last = count(self) - 1;\n        uint256 rowToReplace = self.keyPointers[key];\n        if (rowToReplace != last) {\n            address keyToMove = self.keyList[last];\n            self.keyPointers[keyToMove] = rowToReplace;\n            self.keyList[rowToReplace] = keyToMove;\n        }\n        delete self.keyPointers[key];\n        self.keyList.pop();\n    }\n\n    /**\n     * @notice count the keys.\n     * @param self storage pointer to a Set.\n     */\n    function count(Set storage self) public view returns (uint256) {\n        return (self.keyList.length);\n    }\n\n    /**\n     * @notice check if a key is in the Set.\n     * @param self storage pointer to a Set.\n     * @param key value to check.\n     * @return bool true: Set member, false: not a Set member.\n     */\n    function exists(Set storage self, address key)\n        public\n        view\n        returns (bool)\n    {\n        if (self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     * @notice fetch a key by row (enumerate).\n     * @param self storage pointer to a Set.\n     * @param index row to enumerate. Must be < count() - 1.\n     */\n    function keyAtIndex(Set storage self, uint256 index)\n        public\n        view\n        returns (address)\n    {\n        return self.keyList[index];\n    }\n}\n"
    },
    "src/libraries/AttributeLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nimport \"../interfaces/IAttribute.sol\";\n\nstruct AttributeStorage {\n    AttributeContract attributes;\n}\n\nlibrary AttributeLib {\n    event AttributeSet(address indexed tokenAddress, uint256 tokenId, Attribute attribute);\n    event AttributeRemoved(address indexed tokenAddress, uint256 tokenId, string attributeKey);\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nextblock.bitgem.app.AttributeStorage.storage\");\n\n    function attributeStorage() internal pure returns (AttributeStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice set an attribute for a tokenid keyed by string\n    function _getAttribute(\n        AttributeContract storage self,\n        uint256 tokenId,\n        string memory key\n    ) internal view returns (Attribute memory) {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        return self.attributes[tokenId][key];\n    }\n\n    /// @notice get a list of keys of attributes assigned to this tokenid\n    function _getAttributeValues(\n        uint256 id\n    ) internal view returns (string[] memory) {\n        AttributeContract storage ct = AttributeLib.attributeStorage().attributes;\n        string[] memory keys = ct.attributeKeys[id];\n        string[] memory values = new string[](keys.length);\n        for (uint256 i = 0; i < keys.length; i++) {\n            values[i] = ct.attributes[id][keys[i]].value;\n        }\n        return values;\n    }\n    \n    /// @notice set an attribute to a tokenid keyed by string\n    function _setAttribute(\n        AttributeContract storage self,\n        uint256 tokenId,\n        Attribute memory attribute\n    ) internal {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        if (self.attributeKeysIndexes[tokenId][attribute.key] == 0 \n            && bytes(self.attributes[tokenId][attribute.key].value).length == 0) {\n            self.attributeKeys[tokenId].push(attribute.key);\n            self.attributeKeysIndexes[tokenId][attribute.key] = self.attributeKeys[tokenId].length - 1;\n        }\n        self.attributes[tokenId][attribute.key] = attribute;\n    }\n    \n    /// @notice set multiple  attributes for the token\n    function _setAttributes(\n        AttributeContract storage self,\n        uint256 tokenId, \n        Attribute[] memory _attributes)\n        internal\n    {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        for (uint256 i = 0; i < _attributes.length; i++) {\n            _setAttribute(self, tokenId, _attributes[i]);\n        }\n    }\n\n    /// @notice get a list of keys of attributes assigned to this tokenid\n    function _getAttributeKeys(\n        AttributeContract storage self,\n        uint256 tokenId\n    ) internal view returns (string[] memory) {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        return self.attributeKeys[tokenId];\n    }\n\n    /// @notice remove the attribute for a tokenid keyed by string\n    function _removeAttribute(\n        AttributeContract storage self,\n        uint256 tokenId,\n        string memory key\n    ) internal {\n        require(self.burnedIds[tokenId] == false, \"Token has been burned\");\n        delete self.attributes[tokenId][key];\n        uint256 ndx = self.attributeKeysIndexes[tokenId][key];\n        for (uint256 i = ndx; i < self.attributeKeys[tokenId].length - 1; i++) {\n            self.attributeKeys[tokenId][i] = self.attributeKeys[tokenId][i + 1];\n            self.attributeKeysIndexes[tokenId][self.attributeKeys[tokenId][i]] = i;\n        }\n        delete self.attributeKeys[tokenId][self.attributeKeys[tokenId].length - 1];\n        emit AttributeRemoved(address(this), tokenId, key);\n    }\n\n    // @notice set multiple attributes for the token\n    function _burn(\n        AttributeContract storage self,\n        uint256 tokenId)\n        internal\n    {\n        self.burnedIds[tokenId] = true;\n    }\n}"
    },
    "src/libraries/Bytes32Set.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @notice Key sets with enumeration and delete. Uses mappings for random\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\n * fixed gas cost at any scale, O(1).\n * author: Rob Hitchens\n */\n\nlibrary Bytes32Set {\n    struct Set {\n        mapping(bytes32 => uint256) keyPointers;\n        bytes32[] keyList;\n    }\n\n    /**\n     * @notice insert a key.\n     * @dev duplicate keys are not permitted.\n     * @param self storage pointer to a Set.\n     * @param key value to insert.\n     */\n    function insert(Set storage self, bytes32 key) public {\n        require(\n            !exists(self, key),\n            \"key already exists in the set.\"\n        );\n        self.keyList.push(key);\n        self.keyPointers[key] = self.keyList.length - 1;\n    }\n\n    /**\n     * @notice remove a key.\n     * @dev key to remove must exist.\n     * @param self storage pointer to a Set.\n     * @param key value to remove.\n     */\n    function remove(Set storage self, bytes32 key) public {\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\n        // require(\n        //     exists(self, key),\n        //     \"Bytes32Set: key does not exist in the set.\"\n        // );\n        if (!exists(self, key)) return;\n        uint256 last = count(self) - 1;\n        uint256 rowToReplace = self.keyPointers[key];\n        if (rowToReplace != last) {\n            bytes32 keyToMove = self.keyList[last];\n            self.keyPointers[keyToMove] = rowToReplace;\n            self.keyList[rowToReplace] = keyToMove;\n        }\n        delete self.keyPointers[key];\n        delete self.keyList[self.keyList.length - 1];\n    }\n\n    /**\n     * @notice count the keys.\n     * @param self storage pointer to a Set.\n     */\n    function count(Set storage self) public view returns (uint256) {\n        return self.keyList.length;\n    }\n\n    /**\n     * @notice check if a key is in the Set.\n     * @param self storage pointer to a Set.\n     * @param key value to check.\n     * @return bool true: Set member, false: not a Set member.\n     */\n    function exists(Set storage self, bytes32 key)\n        public\n        view\n        returns (bool)\n    {\n        if (self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     * @notice fetch a key by row (enumerate).\n     * @param self storage pointer to a Set.\n     * @param index row to enumerate. Must be < count() - 1.\n     */\n    function keyAtIndex(Set storage self, uint256 index)\n        public\n        view\n        returns (bytes32)\n    {\n        return self.keyList[index];\n    }\n}\n"
    },
    "src/libraries/ClaimStorageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Claim } from \"../interfaces/IClaimIssuer.sol\";\n\nstruct ClaimStorage {\n    mapping(bytes32 => Claim) claims;\n}\n\nlibrary ClaimStorageLib {\n\n    using Strings for uint256;\n    using Address for address;\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nomyx.app.Claim.storage\");\n\n    function claimStorage() internal pure returns (ClaimStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function getClaim(bytes32 _claimId) internal view returns (Claim memory) {\n        return claimStorage().claims[_claimId];\n    }\n\n}"
    },
    "src/libraries/ClaimTopicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IClaimTopicsRegistry.sol\";\n\nstruct ClaimTopicContract {\n    uint256[] claimTopics;\n}\n\nstruct ClaimTopicStorage {\n    ClaimTopicContract _contract;\n    address owner;\n}\n\nlibrary ClaimTopicLib {\n\n    event ClaimTopicAdded(uint256 indexed claimTopic);\n    event ClaimTopicRemoved(uint256 indexed claimTopic);\n\n    modifier onlyOwner(address caller) {\n        require(caller == claimTopicStorage().owner, \"Caller is not the owner\");\n        _;\n    }\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = \n        keccak256(\"diamond.standard.claimTopics.facet.contract\");\n\n    function claimTopicStorage() internal pure returns (ClaimTopicStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function addClaimTopic(\n        ClaimTopicContract storage self,\n        uint256 _claimTopic,\n        address caller\n    ) internal onlyOwner(caller) {\n        self.claimTopics.push(_claimTopic);\n        emit ClaimTopicAdded(_claimTopic);\n    }\n\n    function removeClaimTopic(\n        ClaimTopicContract storage self,\n        uint256 _claimTopic,\n        address caller\n    ) internal onlyOwner(caller) {\n        for (uint256 i; i < self.claimTopics.length; i++) {\n            if (self.claimTopics[i] == _claimTopic) {\n                self.claimTopics[i] = self.claimTopics[self.claimTopics.length - 1];\n                self.claimTopics.pop();\n                emit ClaimTopicRemoved(_claimTopic);\n                return;\n            }\n        }\n        revert(\"Claim topic not found.\");\n    }\n\n    function getClaimTopics(ClaimTopicContract storage self) internal view returns (uint256[] memory) {\n        return self.claimTopics;\n    }\n}\n"
    },
    "src/libraries/DiamondFactoryLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { TokenDefinition } from \"../interfaces/IToken.sol\";\n\nimport \"../interfaces/IDiamondFactory.sol\";\nimport \"../interfaces/IDiamond.sol\";\n\ninterface IDiamondElement {\n  function initialize(\n    address, \n    DiamondSettings memory,\n    IDiamondCut.FacetCut[] calldata,\n    address,\n    bytes calldata) external payable;\n}\n\nlibrary DiamondFactoryLib {\n\n  bytes32 internal constant DIAMOND_STORAGE_POSITION =\n    keccak256(\"diamond.nextblock.bitgem.app.DiamondFactoryStorage.storage\");\n\n  /// @notice get the storage for the diamond factory\n  /// @return ds DiamondFactoryStorage the storage for the diamond factory\n  function diamondFactoryStorage() internal pure returns (DiamondFactoryStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  /// @notice add a set of facets to the factory and associate with a string name\n  /// @param self the storage for the diamond factory\n  /// @param setName the name of the set of facets\n  /// @param facets the facets to add\n  function _addFacetSet(DiamondFactoryStorage storage self, string memory setName, IDiamondCut.FacetCut[] memory facets) internal {\n    // add the facets to the diamond\n    for (uint256 i = 0; i < facets.length; i++) {\n      self.contractData.facetsToAdd[setName].push(facets[i]);\n    }\n  }\n\n  /// @notice get all the facets for a particular set name\n  /// @param self the storage for the diamond factory\n  /// @param setName the name of the set of facets\n  /// @return IDiamondCut.FacetCut[] the facets for the set name\n  function _getFacets(DiamondFactoryStorage storage self, string memory setName) internal view returns (IDiamondCut.FacetCut[] memory) {\n    return self.contractData.facetsToAdd[setName];\n  }\n\n  /// @notice set a facet for facet set name at a particular index\n  /// @param self the storage for the diamond factory\n  /// @param setName the name of the set of facets\n  /// @param idx the index of the facet to set\n  /// @param facet the facet to set\n  function _setFacet(DiamondFactoryStorage storage self, string memory setName, uint256 idx, IDiamondCut.FacetCut memory facet) internal {\n    self.contractData.facetsToAdd[setName][idx] = facet;        \n  }\n\n  /// @notice get an address for the given diamond\n  /// @param factoryAddress the diamond factory\n  /// @param symbol the symbol of the  diamond\n  /// @param creationCode the creation code for the diamond\n  function _getDiamondAddress(DiamondFactoryStorage storage, address factoryAddress, string memory symbol, bytes memory creationCode)\n    internal\n    view\n    returns (address) {\n    return Create2.computeAddress(\n      keccak256(abi.encodePacked(factoryAddress, symbol)),\n      keccak256(creationCode)\n    );\n  }\n\n    /// @notice create a new diamond token with the given symbol\n    /// @param self the storage for the diamond factory\n    /// @param diamondAddress the diamond address\n    /// @param diamondInit the diamond init data\n    /// @param _calldata  the calldata for the diamond\n    /// @param _creationCode the creation code for the diamond\n    function create(\n        DiamondFactoryStorage storage self,\n        address diamondAddress,\n        DiamondSettings memory params,\n        address diamondInit,\n        bytes calldata _calldata,\n        bytes memory _creationCode,\n        IDiamondCut.FacetCut[] memory facets\n    ) internal returns (address payable _diamondAddress) {\n        // use create2 to create the token\n        _diamondAddress = payable(\n            Create2.deploy(\n                0,\n                keccak256(abi.encodePacked(diamondAddress, params.symbol)),\n                _creationCode\n            )\n        );\n        require(_diamondAddress != address(0), \"create_failed\");\n        \n        // update storage with the new data\n        self.contractData.diamondAddresses[params.symbol] = _diamondAddress;\n        self.contractData.diamondSymbols.push(params.symbol);\n\n        // initialize the diamond contract\n        IDiamondElement(_diamondAddress).initialize(\n            msg.sender,\n            params,\n            facets,\n            diamondInit,\n            _calldata\n        );\n    }\n\n    /// @notice create a new diamond token with the given symbol\n    /// @param self the storage for the diamond factory\n    /// @param diamondAddress the diamond address\n    /// @param diamondInit the diamond init data\n    /// @param _calldata  the calldata for the diamond\n    /// @param _creationCode the creation code for the diamond\n    function createFromSet(\n        DiamondFactoryStorage storage self,\n        address diamondAddress,\n        DiamondSettings memory params,\n        address diamondInit,\n        bytes calldata _calldata,\n        bytes memory _creationCode,\n        string memory facetSet\n    ) internal returns (address payable _diamondAddress) {\n        // use create2 to create the token\n        _diamondAddress = payable(\n            Create2.deploy(\n                0,\n                keccak256(abi.encodePacked(diamondAddress, params.symbol)),\n                _creationCode\n            )\n        );\n        require(_diamondAddress != address(0), \"create_failed\");\n        \n        // update storage with the new data\n        self.contractData.diamondAddresses[params.symbol] = _diamondAddress;\n        self.contractData.diamondSymbols.push(params.symbol);\n\n        // initialize the diamond contract\n        IDiamondElement(_diamondAddress).initialize(\n            msg.sender,\n            params,\n            self.contractData.facetsToAdd[facetSet],\n            diamondInit,\n            _calldata\n        );\n    }\n\n    /// @notice add an existing diamond to this factory\n    /// @param self the storage for the diamond factory\n    /// @param symbol the symbol of the diamond\n    /// @param diamondAddress the address of the diamond\n    function add(\n        DiamondFactoryStorage storage self,\n        string memory symbol,\n        address payable diamondAddress\n    ) internal {\n        // update storage with the new data\n        self.contractData.diamondAddresses[symbol] = diamondAddress;\n        self.contractData.diamondSymbols.push(symbol);\n    }\n\n    /// @notice remove a diamond from this factory\n    /// @param self the storage for the diamond factory\n    /// @param symbol the symbol of the diamond\n    function remove(\n      DiamondFactoryStorage storage self,\n      string memory symbol\n    ) internal {\n        self.contractData.diamondAddresses[symbol] = address(0);\n        for(uint256 i = 0; i < self.contractData.diamondSymbols.length; i++) {\n            if ( keccak256(bytes(self.contractData.diamondSymbols[i] ) ) == keccak256(bytes(symbol)) ) {\n                self.contractData.diamondSymbols[i] = self.contractData.diamondSymbols[self.contractData.diamondSymbols.length - 1];\n                self.contractData.diamondSymbols.pop();\n                break;\n            }\n        }\n    }\n}\n"
    },
    "src/libraries/DiamondLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { DiamondStorage } from \"../interfaces/IDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { TokenDefinition } from \"../interfaces/IToken.sol\";\n\nimport \"./LibDiamond.sol\";\nimport \"./ERC721ALib.sol\";\n\nimport \"../upgradeInitializers/DiamondInit.sol\";\n\nlibrary DiamondLib {\n\n  bytes32 internal constant DIAMOND_STORAGE_POSITION =\n    keccak256(\"diamond.nextblock.bitgem.app.DiamondStorage.storage\");\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n}\n"
    },
    "src/libraries/ERC721AEnumerationLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nimport \"../interfaces/IERC721Enumerable.sol\";\n\n\nlibrary ERC721AEnumerationLib {\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(ERC721EnumerableContract storage self, address owner, uint256 index) internal view returns (uint256) {\n        require(index < IERC721(address(this)).balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return self._ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply(ERC721EnumerableContract storage self) internal view returns (uint256) {\n        return self._allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(ERC721EnumerableContract storage self, uint256 index) internal view returns (uint256) {\n        require(index < totalSupply(self), \"ERC721Enumerable: global index out of bounds\");\n        return self._allTokens[index];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(ERC721EnumerableContract storage self, address to, uint256 tokenId) internal {\n        uint256 length = IERC721(address(this)).balanceOf(to);\n        self._ownedTokens[to][length] = tokenId;\n        self._ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(ERC721EnumerableContract storage self, uint256 tokenId) internal {\n        self._allTokensIndex[tokenId] = self._allTokens.length;\n        self._allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(ERC721EnumerableContract storage self, address from, uint256 tokenId) internal {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n        uint256 lastTokenIndex = IERC721(address(this)).balanceOf(from) - 1;\n        uint256 tokenIndex = self._ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = self._ownedTokens[from][lastTokenIndex];\n\n            self._ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            self._ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete self._ownedTokensIndex[tokenId];\n        delete self._ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(ERC721EnumerableContract storage self, uint256 tokenId) internal {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n        uint256 lastTokenIndex = self._allTokens.length - 1;\n        uint256 tokenIndex = self._allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = self._allTokens[lastTokenIndex];\n\n        self._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        self._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete self._allTokensIndex[tokenId];\n        self._allTokens.pop();\n    }\n\n}"
    },
    "src/libraries/ERC721ALib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Creator: Chiru Labs\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\n\nimport \"../interfaces/IERC721A.sol\";\nimport \"../interfaces/IERC721Enumerable.sol\";\n\n\n/* solhint-disable indent */\n/* solhint-disable mark-callable-contracts */\n\nerror ApprovalCallerNotOwnerNorApproved();\nerror ApprovalQueryForNonexistentToken();\nerror ApproveToCaller();\nerror ApprovalToCurrentOwner();\nerror BalanceQueryForZeroAddress();\nerror MintedQueryForZeroAddress();\nerror BurnedQueryForZeroAddress();\nerror AuxQueryForZeroAddress();\nerror MintToZeroAddress();\nerror MintZeroQuantity();\nerror OwnerIndexOutOfBounds();\nerror OwnerQueryForNonexistentToken();\nerror TokenIndexOutOfBounds();\nerror TransferCallerNotOwnerNorApproved();\nerror TransferFromIncorrectOwner();\nerror TransferToNonERC721ReceiverImplementer();\nerror TransferToZeroAddress();\nerror URIQueryForNonexistentToken();\n\nstruct ERC721AStorage {\n    ERC721EnumerableContract enumerations;\n    ERC721AContract erc721Contract;\n}\n\nlibrary ERC721ALib {\n\n    using Strings for uint256;\n    using Address for address;\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nextblock.bitgem.app.ERC721AStorage.storage\");\n\n    function erc721aStorage() internal pure returns (ERC721AStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * Returns the total number of minted tokens\n     */\n    function totalSupply(ERC721AContract storage self) internal view returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than _currentIndex times\n        unchecked {\n            return self._currentIndex - self._burnCounter;\n        }\n    }\n    \n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(ERC721AContract storage self, address owner) internal view returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(self._addressData[owner].balance);\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(ERC721AContract storage self, address owner) internal view returns (uint256) {\n        if (owner == address(0)) revert MintedQueryForZeroAddress();\n        return uint256(self._addressData[owner].numberMinted);\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(ERC721AContract storage self, address owner) internal view returns (uint256) {\n        if (owner == address(0)) revert BurnedQueryForZeroAddress();\n        return uint256(self._addressData[owner].numberBurned);\n    }\n\n    /**\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(ERC721AContract storage self, address owner) internal view returns (uint64) {\n        if (owner == address(0)) revert AuxQueryForZeroAddress();\n        return self._addressData[owner].aux;\n    }\n\n    /**\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(ERC721AContract storage self, address owner, uint64 aux) internal {\n        if (owner == address(0)) revert AuxQueryForZeroAddress();\n        self._addressData[owner].aux = aux;\n    }\n\n    function ownershipOf(ERC721AContract storage self, uint256 tokenId) internal view returns (TokenOwnership memory) {\n        uint256 curr = tokenId;\n        unchecked {\n            if (curr < self._currentIndex) {\n                TokenOwnership memory ownership = self._ownerships[curr];\n                if (!ownership.burned) {\n                    if (ownership.addr != address(0)) {\n                        return ownership;\n                    }\n                    // Invariant:\n                    // There will always be an ownership that has an address and is not burned\n                    // before an ownership that does not have an address and is not burned.\n                    // Hence, curr will not underflow.\n                    while (true) {\n                        curr--;\n                        ownership = self._ownerships[curr];\n                        if (ownership.addr != address(0)) {\n                            return ownership;\n                        }\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(ERC721AContract storage self, uint256 tokenId) internal view returns (bool) {\n        return tokenId < self._currentIndex && !self._ownerships[tokenId].burned;\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(ERC721AContract storage self, uint256 tokenId) internal view returns (address) {\n        if (!_exists(self, tokenId)) revert ApprovalQueryForNonexistentToken();\n        return self._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(ERC721AContract storage self, address sender, address operator, bool approved) internal {\n        self._operatorApprovals[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(ERC721AContract storage self, address owner, address operator) internal view returns (bool) {\n        return self._operatorApprovals[owner][operator];\n    }\n\n    function currentIndex(ERC721AContract storage self) internal view returns (uint256) {\n        return self._currentIndex;\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(\n        ERC721AContract storage self,\n        address msgSender,\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        uint256 startTokenId = self._currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(self, address(0), to, startTokenId, quantity);\n\n        unchecked {\n            self._addressData[to].balance += uint64(quantity);\n            self._addressData[to].numberMinted += uint64(quantity);\n\n            self._ownerships[startTokenId].addr = to;\n            self._ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n\n            for (uint256 i; i < quantity; i++) {\n                emit Transfer(address(0), to, updatedIndex);\n                if (safe && !_checkOnERC721Received(msgSender, address(0), to, updatedIndex, _data)) {\n                    revert TransferToNonERC721ReceiverImplementer();\n                }\n                updatedIndex++;\n            }\n\n            self._currentIndex = updatedIndex;\n        }\n\n        _afterTokenTransfers(self, address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        ERC721AContract storage self,\n        address msgSender,\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        TokenOwnership memory prevOwnership = ownershipOf(self, tokenId);\n\n        bool isApprovedOrOwner = (msgSender == prevOwnership.addr ||\n            isApprovedForAll(self, prevOwnership.addr, msgSender) ||\n            getApproved(self, tokenId) == msgSender);\n\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(self, from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(self, address(0), tokenId, prevOwnership.addr);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            self._addressData[from].balance -= 1;\n            self._addressData[to].balance += 1;\n\n            self._ownerships[tokenId].addr = to;\n            self._ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (self._ownerships[nextTokenId].addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId < self._currentIndex) {\n                    self._ownerships[nextTokenId].addr = prevOwnership.addr;\n                    self._ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(self, from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(ERC721AContract storage self, uint256 tokenId) internal {\n        TokenOwnership memory prevOwnership = ownershipOf(self, tokenId);\n\n        _beforeTokenTransfers(self, prevOwnership.addr, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(self, address(0), tokenId, prevOwnership.addr);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            self._addressData[prevOwnership.addr].balance -= 1;\n            self._addressData[prevOwnership.addr].numberBurned += 1;\n\n            // Keep track of who burned the token, and the timestamp of burning.\n            self._ownerships[tokenId].addr = prevOwnership.addr;\n            self._ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n            self._ownerships[tokenId].burned = true;\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (self._ownerships[nextTokenId].addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId < self._currentIndex) {\n                    self._ownerships[nextTokenId].addr = prevOwnership.addr;\n                    self._ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(prevOwnership.addr, address(0), tokenId);\n        _afterTokenTransfers(self, prevOwnership.addr, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            self._burnCounter++;\n        }\n    }\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        ERC721AContract storage self,\n        address to,\n        uint256 tokenId,\n        address owner\n    ) internal {\n        self._tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address msgSender,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(msgSender, from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert TransferToNonERC721ReceiverImplementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        ERC721AContract storage self,\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     * And also called after one token has been burned.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        ERC721AContract storage self,\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal {}\n}"
    },
    "src/libraries/IdentityLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport {IIdentity} from \"../interfaces/IIdentity.sol\";\nimport {IIdentityRegistry} from \"../interfaces/IIdentityRegistry.sol\";\n\nstruct Identity {\n    IIdentity identityData;\n    uint16 country;\n    mapping(uint256 => bytes) claims;\n    mapping(uint256 => bool) claimTopics;\n}\n\nstruct IdentityContract {\n    mapping(address => Identity) identities;\n    address[] identityOwners;\n    address[] identityAddresses;\n    mapping(address => bytes32) addressToOnchainID;\n}\n\nstruct IdentityStorage {\n    IdentityContract identityContract;\n}\n\nlibrary IdentityLib {\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nomyx.IdentityRegistryFacet.IdentityStorage\");\n\n    event IdentityAdded(address indexed _address, IIdentity identity);\n    event IdentityRemoved(address indexed _address, IIdentity identity);\n\n    function identityStorage() internal pure returns (IdentityStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice get an Identity for an address\n    function _getIdentity(\n        IdentityContract storage,\n        address _identityAddress\n    ) internal view returns (Identity storage) {\n        return identityStorage().identityContract.identities[_identityAddress];\n    }\n\n    /// @notice set an Identity for a tokenid keyed by string\n    function _setIdentity(\n        IdentityContract storage self,\n        address _identityAddress,\n        Identity storage identity\n    ) internal {\n        self.identities[_identityAddress].identityData = identity.identityData;\n        self.identities[_identityAddress].country = identity.country;\n        self.identityAddresses.push(_identityAddress);\n        emit IdentityAdded(_identityAddress, identity.identityData);\n    }\n\n    /// @notice remove an Identity for an address\n    function _removeIdentity(\n        IdentityContract storage self,\n        address _identityAddress\n    ) internal {\n        delete self.identities[_identityAddress];\n        \n        uint256 index;\n        for (uint256 i = 0; i < self.identityAddresses.length; i++) {\n            if (self.identityAddresses[i] == _identityAddress) {\n                index = i;\n                break;\n            }\n        }\n        if (index != self.identityAddresses.length - 1) {\n            self.identityAddresses[index] = self.identityAddresses[self.identityAddresses.length - 1];\n        }\n        self.identityAddresses.pop();\n        emit IdentityRemoved(_identityAddress, self.identities[_identityAddress].identityData);\n    }\n\n}\n"
    },
    "src/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        //require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "src/libraries/MetadataLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\n\nimport \"./StringsLib.sol\";\n\nimport \"../interfaces/IMetadata.sol\";\nimport \"../interfaces/IAttribute.sol\";\nimport \"../interfaces/IDiamond.sol\";\n\nimport \"./SVGTemplatesLib.sol\";\nimport \"./AttributeLib.sol\";\n\nimport \"../utilities/SVGManager.sol\";\n\nimport \"hardhat/console.sol\";\n\n/* solhint-disable mark-callable-contracts */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable no-unused-vars */\n/* solhint-disable two-lines-top-level-separator */\n/* solhint-disable quotes */\n/* solhint-disable indent */\n\nstruct MetadataStorage {\n    MetadataContract metadata;\n}\n\nlibrary MetadataLib {\n    using Strings for uint256;\n    using StringsLib for string;\n    using AttributeLib for AttributeContract;\n\n    bytes32 internal constant TYPE_HASH = keccak256(\"type\");\n    bytes32 internal constant CLAIM_HASH = keccak256(\"claim\");\n      \n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nextblock.bitgem.app.MetadataStorage.storage\");\n\n    function metadataStorage() internal pure returns (MetadataStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setMetadata(MetadataContract storage, MetadataContract memory _contract) internal {\n        metadataStorage().metadata = _contract;\n    }\n\n    /// @notice return the name of the metadata\n    function name(MetadataContract storage self)\n        internal\n        view\n        returns (string memory) { return self._name; }\n\n    /// @notice return the symnbol of the metadata\n    function symbol(MetadataContract storage self)\n        internal\n        view\n        returns (string memory) { return self._symbol; }\n\n    /// @notice return the description of the metadata\n    function description(MetadataContract storage self)\n        internal\n        view\n        returns (string memory) { return self._description; }\n\n    /// @notice return the image of the metadata\n    function image(MetadataContract storage self)\n        internal\n        view\n        returns (string memory) {\n            (, string memory svg) = getContractImage(self);\n            return svg;\n        }\n\n    /// @notice get the image for the contract\n    function getContractImage(\n        MetadataContract storage self\n    ) internal view returns (address addr, string memory svg) {\n\n        // get the image, error if no image\n        SVGManager mgr = SVGManager(SVGTemplatesLib.svgStorage().svgManager);\n\n        try mgr.svgAddress(self._imageName) returns (address _addr) {\n            address imageAddress = addr = _addr;\n            require(imageAddress != address(0), \"no image hash been set\");   \n            \n            string[] memory cccc = new string[](4);\n            cccc[0] = \"CUT\";\n            cccc[1] = \"COLOR\";\n            cccc[2] = \"CARAT\";\n            cccc[3] = \"CLARITY\";\n            Replacement[] memory replacements =\n                _getReplacements(\n                    self._imageColors,\n                    cccc\n                );\n\n            svg = ISVGTemplate(imageAddress).buildSVG(replacements);\n        } catch(bytes memory) {\n            svg = self._imageName;\n        }\n    }\n\n    /// @notice get the image for the gem\n    function getTokenImage(\n        MetadataContract storage,\n        DiamondContract storage,\n        AttributeContract storage a,\n        uint256 tokenId\n    ) internal view returns (string memory svg, Attribute[] memory attributes) {\n\n        // get the attributes for the token\n        string[] memory attributeKeys = AttributeLib._getAttributeKeys(a, tokenId);\n        attributes = new Attribute[](attributeKeys.length);\n        string[] memory cccc = AttributeLib._getAttributeValues(tokenId);\n\n        for(uint256 i = 0; i < attributeKeys.length; i++) {\n            attributes[i] = Attribute({\n                key: attributeKeys[i],\n                attributeType: AttributeType.String,\n                value: cccc[i]\n            });\n        }\n\n        // get the image, error if no image\n        string memory key = string(abi.encodePacked(\"image_\", tokenId.toString()));\n        string memory val = AttributeLib._getAttribute(a, tokenId, key).value;\n        svg = val;\n        \n        // Replacement[] memory replacements;\n        // if (!val.startsWith('0x')) {\n        //     svg = val;\n        // } else {\n        //     SVGManager mgr = SVGManager(SVGTemplatesLib.svgStorage().svgManager);\n        //     address imageAddress = mgr.svgAddress(key);\n        //     if (imageAddress == address(0)) imageAddress = mgr.svgAddress(self._imageName);\n        //     replacements =\n        //     _getReplacements(\n        //         self._imageColors,\n        //         cccc);\n        //     svg = ISVGTemplate(imageAddress).buildSVG(replacements);\n        // }\n    }\n\n    function setTokenImage(\n        MetadataContract storage,\n        AttributeContract storage a,\n        uint256 tokenId,\n        string memory svg\n    ) internal {\n        string memory key = string(abi.encodePacked(\"image_\", tokenId.toString()));\n        a._setAttribute(tokenId, Attribute(\n            key,\n            AttributeType.String,\n            svg\n        ));\n    }\n\n    function _setMetadataSource(\n        MetadataContract storage self,\n        MetadataSource source\n    ) internal {\n        self._metadataSource = source;\n    }\n\n    function _setBaseURI(MetadataContract storage self, string memory baseURI)\n        internal {\n        self._baseUri = baseURI;\n    }\n\n    /// @notice get th replacement values for the svg\n    function _getReplacements(\n        string[] memory colorPalette,\n        string[] memory cccc\n    ) internal pure returns (Replacement[] memory) {\n        if(colorPalette.length == 0) {\n            return new Replacement[](4);\n        }\n        Replacement[] memory replacements = new Replacement[](\n            colorPalette.length + 4\n        );\n        for (uint256 i = 0; i < colorPalette.length; i++) {\n            replacements[i] = Replacement(\n                string(abi.encodePacked(\"COLOR \", Strings.toString(i))),\n                colorPalette[i]\n            );\n        }\n        uint256 l = colorPalette.length;\n        replacements[l] = Replacement(\"CUT\", cccc[0]);\n        replacements[l + 1] = Replacement(\"COLOR\", cccc[1]);\n        replacements[l + 2] = Replacement(\"CARAT\", cccc[2]);\n        replacements[l + 3] = Replacement(\"CLARITY\", cccc[3]);\n        return replacements;\n    }\n\n\n    /// @notice See {IERC721Metadata-tokenURI}.\n    function tokenURI(\n        MetadataContract storage self,\n        DiamondContract storage diamond,\n        AttributeContract storage attribs,\n        uint256 tokenId\n    ) internal view returns (string memory) {\n\n        // get the token image and attributes\n        (string memory svg, Attribute[] memory attributes) = getTokenImage(\n            self,\n            diamond,\n            attribs,\n            tokenId\n        );\n\n        // turn the attributes into traits\n        Trait[] memory traits = new Trait[](attributes.length);\n        string memory _name = diamond.settings.name;\n        for (uint256 i = 0; i < attributes.length; i++) {\n            traits[i] = Trait(\"\", attributes[i].key, attributes[i].value);\n            // add the word 'claim' to the name if the attribute is a claim\n            if (\n                TYPE_HASH == keccak256(bytes(attributes[i].key)) &&\n                CLAIM_HASH == keccak256(bytes(attributes[i].value))\n            ) {\n                _name = string(abi.encodePacked(_name, \" Claim\"));\n            }\n        }\n        // base64 encode the token data and return it\n        string memory json = Base64.encode(\n            bytes(getTokenMetadata(self, traits, svg))\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function contractURI(MetadataContract storage self)\n        internal\n        view\n        returns (string memory) {\n        Trait[] memory dum;\n        (, string memory svg) = getContractImage(self);\n        string memory json = Base64.encode(\n            bytes(\n                getTokenMetadata(self, dum,  svg)\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice create a metadata trait\n    function createTrait(\n        string memory displayType,\n        string memory key,\n        string memory value\n    ) internal pure returns (string memory trait) {\n        // ensure key is not empty\n        require(bytes(key).length > 0, \"key cannot be empty\");\n        // if has a display type, then output the display type\n        bool hasDisplayType = bytes(displayType).length > 0;\n        if (hasDisplayType) {\n            displayType = string(\n                abi.encodePacked('\"display_type\": \"', displayType, '\",')\n            );\n            // if this is a number, then don't quote it, otherwise quote it\n            bool isNumber = StringsLib.startsWith(displayType, \"number\") ||\n                StringsLib.endsWith(displayType, \"percentage\");\n            if (!isNumber) value = string(abi.encodePacked('\"', value, '\"'));\n            else value = string(abi.encodePacked(value));\n        } else value = string(abi.encodePacked('\"', value, '\"'));\n        // return the trait\n        trait = string(\n            abi.encodePacked(\n                \"{\",\n                displayType,\n                '\"trait_type\": \"',\n                key,\n                '\", \"value\": ',\n                value,\n                \"}\"\n            )\n        );\n    }\n\n    /// @notice given an array of trait structs, create a metadata string\n    function arrayizeTraits(Trait[] memory _traits)\n        internal\n        pure\n        returns (string memory _traitsString)\n    {\n        bytes memory traitBytes = \"[\";\n        for (uint256 i = 0; i < _traits.length; i++) {\n            Trait memory traitObj = _traits[i];\n            string memory trait = createTrait(\n                traitObj.displayType,\n                traitObj.key,\n                traitObj.value\n            );\n            traitBytes = abi.encodePacked(traitBytes, trait);\n            if (i < _traits.length - 1) {\n                traitBytes = abi.encodePacked(traitBytes, \",\");\n            }\n        }\n        _traitsString = string(abi.encodePacked(traitBytes, \"]\"));\n    }\n\n    /// @notice create a metadata string from a metadata struct\n    function getTokenMetadata(\n        MetadataContract memory definition,\n        Trait[] memory _traits,\n        string memory _imageData\n    ) internal pure returns (string memory metadata) {\n        if(!_imageData.startsWith(\"0x\")) {\n            _imageData = string(abi.encodePacked('\"', _imageData, '\"'));\n        }\n        string memory traitsString = arrayizeTraits(_traits);\n        string memory externalUrl = bytes(definition._externalUri).length > 0\n            ? string(\n                abi.encodePacked(\n                    '\"external_url\": \"',\n                    definition._externalUri,\n                    '\"'\n                )\n            )\n            : string(abi.encodePacked('\"external_url\"', ': \"', '\"'));\n        bytes memory a1 = abi.encodePacked(\n            '{\"name\": \"',\n            definition._name,\n            '\", \"image\": ',\n            _imageData,\n            ', \"description\": \"',\n            definition._description,\n            '\", ',\n            externalUrl\n        );\n        if (_traits.length > 0) {\n            a1 = abi.encodePacked(a1, ', \"attributes\": ', traitsString);\n        }\n        metadata = string(abi.encodePacked(a1, \"}\"));\n    }\n}\n"
    },
    "src/libraries/StringsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../interfaces/IStrings.sol\";\n\nlibrary StringsLib {\n\n    function parseInt(string memory s) internal pure returns (uint256 res) {\n\n        for (uint256 i = 0; i < bytes(s).length; i++) {\n            if ((uint8(bytes(s)[i]) - 48) < 0 || (uint8(bytes(s)[i]) - 48) > 9) {\n                return 0;\n            }\n            res += (uint8(bytes(s)[i]) - 48) * 10**(bytes(s).length - i - 1);\n        }\n        return res;\n\n    }\n\n    function startsWith(string memory haystack, string memory needle)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes memory haystackBytes = bytes(haystack);\n        bytes memory needleBytes = bytes(needle);\n        uint256 haystackLength = haystackBytes.length;\n        uint256 needleLength = needleBytes.length;\n        if (needleLength > haystackLength) {\n            return false;\n        }\n        for (uint256 i = 0; i < needleLength; i++) {\n            if (haystackBytes[i] != needleBytes[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function endsWith(string memory haystack, string memory needle)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes memory haystackBytes = bytes(haystack);\n        bytes memory needleBytes = bytes(needle);\n        uint256 haystackLength = haystackBytes.length;\n        uint256 needleLength = needleBytes.length;\n        if (needleLength > haystackLength) {\n            return false;\n        }\n        for (uint256 i = 0; i < needleLength; i++) {\n            if (\n                haystackBytes[haystackLength - i - 1] !=\n                needleBytes[needleLength - i - 1]\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function substring(string memory haystack, uint256 startpos)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory haystackBytes = bytes(haystack);\n        uint256 length = haystackBytes.length;\n        uint256 endpos = length - startpos;\n        bytes memory substringBytes = new bytes(endpos);\n        for (uint256 i = 0; i < endpos; i++) {\n            substringBytes[i] = haystackBytes[startpos + i];\n        }\n        return string(substringBytes);\n    }\n\n    function substring(string memory haystack, uint256 startpos, uint256 endpos)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory haystackBytes = bytes(haystack);\n        uint256 substringLength = endpos - startpos;\n        bytes memory substringBytes = new bytes(substringLength);\n        for (uint256 i = 0; i < substringLength; i++) {\n            substringBytes[i] = haystackBytes[startpos + i];\n        }\n        return string(substringBytes);\n    }\n\n    function concat(string[] memory _strings)\n        internal\n        pure\n        returns (string memory _concat)\n    {\n        _concat = \"\";\n        for (uint256 i = 0; i < _strings.length; i++) {\n            _concat = string(abi.encodePacked(_concat, _strings[i]));\n        }\n        return _concat;\n    }\n\n    function split(string memory _string, string memory _delimiter) internal pure returns (string[] memory _split) {\n        _split = new string[](0);\n        uint256 _delimiterLength = bytes(_delimiter).length;\n        uint256 _stringLength = bytes(_string).length;\n        uint256 _splitLength = 0;\n        uint256 _splitIndex = 0;\n        uint256 _startpos = 0;\n        uint256 _endpos = 0;\n        for (uint256 i = 0; i < _stringLength; i++) {\n            if (bytes(_string)[i] == bytes(_delimiter)[0]) {\n                _endpos = i;\n                if (_endpos - _startpos > 0) {\n                    _split[_splitIndex] = substring(_string, _startpos);\n                    _splitIndex++;\n                    _splitLength++;\n                }\n                _startpos = i + _delimiterLength;\n            }\n        }\n        if (_startpos < _stringLength) {\n            _split[_splitIndex] = substring(_string, _startpos);\n            _splitIndex++;\n            _splitLength++;\n        }\n        return _split;\n    }\n\n    function join(string[] memory _strings, string memory _delimiter) internal pure returns (string memory _joined) {\n        for (uint256 i = 0; i < _strings.length; i++) {\n            _joined = string(abi.encodePacked(_joined, _strings[i]));\n            if (i < _strings.length - 1) {\n                _joined = string(abi.encodePacked(_joined, _delimiter));\n            }\n        }\n        return _joined;\n    }\n\n    function replace(string memory _string, string memory _search, string memory _replace) internal pure returns (string memory _replaced) {\n        _replaced = _string;\n        uint256 _searchLength = bytes(_search).length;\n        uint256 _stringLength = bytes(_string).length;\n        uint256 _replacedLength = _stringLength;\n        uint256 _startpos = 0;\n        uint256 _endpos = 0;\n        for (uint256 i = 0; i < _stringLength; i++) {\n            if (bytes(_string)[i] == bytes(_search)[0]) {\n                _endpos = i;\n                if (_endpos - _startpos > 0) {\n                    _replaced = substring(_replaced, _startpos);\n                    _replacedLength -= _endpos - _startpos;\n                }\n                _replaced = string(abi.encodePacked(_replaced, _replace));\n                _replacedLength += bytes(_replace).length;\n                _startpos = i + _searchLength;\n            }\n        }\n        if (_startpos < _stringLength) {\n            _replaced = substring(_replaced, _startpos);\n            _replacedLength -= _stringLength - _startpos;\n        }\n        return _replaced;\n    }\n\n    function trim(string memory _string) internal pure returns (string memory _trimmed) {\n        _trimmed = _string;\n        uint256 _stringLength = bytes(_string).length;\n        uint256 _startpos = 0;\n        uint256 _endpos = 0;\n        for (uint256 i = 0; i < _stringLength; i++) {\n            if (bytes(_string)[i] != 0x20) {\n                _startpos = i;\n                break;\n            }\n        }\n        for (uint256 i = _stringLength - 1; i >= 0; i--) {\n            if (bytes(_string)[i] != 0x20) {\n                _endpos = i;\n                break;\n            }\n        }\n        if (_startpos < _endpos) {\n            _trimmed = substring(_trimmed, _startpos);\n            _trimmed = substring(_trimmed, 0, _endpos - _startpos + 1);\n        }\n        return _trimmed;\n    }\n\n    function toUint16(string memory s) internal pure returns (uint16 res_) {\n        uint256 res = 0;\n        for (uint256 i = 0; i < bytes(s).length; i++) {\n            if ((uint8(bytes(s)[i]) - 48) < 0 || (uint8(bytes(s)[i]) - 48) > 9) {\n                return 0;\n            }\n            res += (uint8(bytes(s)[i]) - 48) * 10**(bytes(s).length - i - 1);\n        }\n        res_ = uint16(res);\n    }\n\n\n    function replace(string[] memory input, string memory matchTag, string[] memory repl) internal pure returns (string memory) {\n        string memory svgBody;\n        for(uint256 i = 0; i < input.length; i++) {\n            string memory svgString = input[i];\n            string memory outValue;\n            if(StringsLib.startsWith(svgString, matchTag)) {\n                string memory restOfLine = StringsLib.substring(svgString, bytes(matchTag).length);\n                uint256 replIndex = StringsLib.parseInt(restOfLine);\n                outValue = repl[replIndex];\n            } else {\n                outValue = svgString;\n            }\n            svgBody = string(abi.encodePacked(svgBody, outValue));\n        }\n        return svgBody;\n    }\n\n    function replace(bytes[] memory sourceBytes, Replacement[] memory replacements_) public pure returns (string memory) {\n        //bytes[] memory sourceBytes = _getSourceBytes();\n        string memory outputFile = \"\";\n        for (uint256 i = 0; i < sourceBytes.length; i++) {\n            bytes memory sourceByte = sourceBytes[i];\n            string memory outputLine  = string(sourceBytes[i]);\n            for (uint256 j = 0; j < replacements_.length; j++) {\n                Replacement memory replacement = replacements_[j];\n                if (keccak256(sourceByte) == keccak256(bytes(replacement.matchString))) {\n                    outputLine = replacement.replaceString;\n                }\n            }\n            outputFile = string(abi.encodePacked(outputFile, outputLine));\n        }\n        return outputFile;\n    }    \n}\n"
    },
    "src/libraries/SVGTemplatesLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport \"../interfaces/ISVG.sol\";\nimport \"../interfaces/IStrings.sol\";\nimport \"../interfaces/IMultiPart.sol\";\n\nimport \"../libraries/StringsLib.sol\";\n\nimport \"../utilities/SVGTemplate.sol\";\n\nstruct SaltStorage {\n    uint256 salt;\n}\n\nstruct SVGStorage {\n    SVGTemplatesContract svgTemplates;\n    SaltStorage salt;    \n    address svgManager;\n    MultiPartContract multiPart;\n}\n\nlibrary SVGTemplatesLib {\n\n    event SVGTemplateCreated(string name, address template);\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nextblock.bitgem.app.SVGStorage.storage\");\n\n    function svgStorage() internal pure returns (SVGStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n    \n    /// @notice get the stored template names in the contract\n    /// @return the names of the templates\n    function _svgs(SVGTemplatesContract storage self)\n        internal\n        view\n        returns (string[] memory) { return self._templateNames; }\n\n    /// @notice get the create2 address of the given name\n    function _svgAddress(\n        SVGTemplatesContract storage,\n        string memory _name) \n        internal \n        view returns (address) {\n        return Create2.computeAddress(\n            keccak256(abi.encodePacked(_name)), \n            keccak256(type(SVGTemplate).creationCode)\n        );  \n    }\n\n    /// @notice the svg string or an empty string\n    function _svgString(\n        SVGTemplatesContract storage self,\n        string memory _name\n    ) internal view returns (string memory data_) {\n        try SVGTemplate(_svgAddress(self, _name)).svgString() returns (string memory _data) {\n            data_ = _data;\n        } catch (bytes memory) {}\n    }\n\n    /// @notice the sstored address for the name storage. empty is no svg\n    function _svgData(\n        SVGTemplatesContract storage self,\n        string memory _name\n    ) internal view returns (address) {\n        return self._templates[_name];\n    }\n\n    /// @notice create a new SVG image with the given name\n    function _createSVG(SVGTemplatesContract storage self, address sender, string memory _name)\n        internal\n        returns (address _tplAddress)\n    {\n        // make sure the name is unique\n        require(\n            self._templates[_name] == address(0),\n            \"template already deployed\"\n        );\n\n        // get the address for the given name, create using create2,\n        // then verify that create2 returned the expected address\n        address targetTplAddress = _svgAddress(self, _name);\n        _tplAddress = Create2.deploy(\n            0,\n            keccak256(abi.encodePacked(_name)),\n            type(SVGTemplate).creationCode\n        );\n        require(targetTplAddress == _tplAddress, \"template address mismatch\");\n\n        // transfer ownership to the creator and update storage\n        Ownable(_tplAddress).transferOwnership(sender);\n        self._templateNames.push(_name);\n        self._templates[_name] = _tplAddress;\n    }\n}\n"
    },
    "src/libraries/TrustedIssuerLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IClaimIssuer } from \"../interfaces/IClaimIssuer.sol\";\nimport { ITrustedIssuersRegistry, TrustedIssuer } from \"../interfaces/ITrustedIssuersRegistry.sol\";\n\nstruct TrustedIssuerContract {\n    mapping(address => TrustedIssuer) trustedIssuers;\n    address[] trustedIssuerAddresses;\n    address owner;\n}\n\nstruct TrustedIssuerStorage {\n    TrustedIssuerContract trustedIssuerContract;\n}\n\n/// \nlibrary TrustedIssuerLib {\n\n    event TrustedIssuerUpdated(address indexed issuerAddress, TrustedIssuer trustedIssuer);\n\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.nomyx.lenderlabs.TrustedIssuerStorage.storage\");\n\n    modifier onlyOwner() {\n        require(msg.sender == trustedIssuerStorage().trustedIssuerContract.owner, \"Caller is not the owner\");\n        _;\n    }\n\n    /// @notice Get the storage struct for the TrustedIssuerRegistry\n    /// @return ds TrustedIssuerStorage struct for the TrustedIssuerRegistry\n    function trustedIssuerStorage() internal pure returns (TrustedIssuerStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice Get the trusted issuer struct given the trusted issuer address \n    /// @param issuerAddress The address of the trusted issuer\n    /// @return trustedIssuer The trusted issuer struct\n    function _getTrustedIssuer(\n        TrustedIssuerContract storage,\n        address issuerAddress\n    ) internal view returns (TrustedIssuer memory trustedIssuer) {\n        return trustedIssuerStorage().trustedIssuerContract.trustedIssuers[issuerAddress];\n    }\n\n    /// @notice Set the trusted issuer struct given the trusted issuer address\n    /// @param self The TrustedIssuerContract storage struct\n    /// @param issuerAddress The address of the trusted issuer\n    /// @param trustedIssuer The trusted issuer struct\n    function _setTrustedIssuer(\n        TrustedIssuerContract storage self,\n        address issuerAddress,\n        TrustedIssuer memory trustedIssuer\n    ) internal {\n        if(self.trustedIssuers[issuerAddress].claimIssuer == address(0)) {\n            self.trustedIssuerAddresses.push(issuerAddress);\n        }\n        self.trustedIssuers[issuerAddress] = trustedIssuer; \n        emit TrustedIssuerUpdated(issuerAddress, trustedIssuer);\n    }\n\n    /// @notice Add a trusted issuer\n    /// @param _trustedIssuer The address of the trusted issuer\n    /// @param _claimTopics The claim topics that the trusted issuer is allowed to issue\n    function _addTrustedIssuer(\n        TrustedIssuerContract storage,\n        address _trustedIssuer, \n        uint[] calldata _claimTopics) internal {\n\n        TrustedIssuer memory trustedIssuer = TrustedIssuer({\n            claimIssuer: _trustedIssuer,\n            claimTopics: _claimTopics\n        });\n\n        _setTrustedIssuer(\n            trustedIssuerStorage().trustedIssuerContract,\n            address(_trustedIssuer),\n            trustedIssuer\n        );\n    }\n\n    /// @notice Remove a trusted issuer\n    /// @param self The TrustedIssuerContract storage struct\n    /// @param _trustedIssuer The address of the trusted issuer\n    function removeTrustedIssuer(TrustedIssuerContract storage self, address _trustedIssuer) internal {\n        delete self.trustedIssuers[address(_trustedIssuer)];\n    }\n\n    /// @notice Update the claim topics that a trusted issuer is allowed to issue\n    /// @param self The TrustedIssuerContract storage struct\n    /// @param _trustedIssuer The address of the trusted issuer\n    /// @param _claimTopics The claim topics that the trusted issuer is allowed to issue\n    function updateIssuerClaimTopics(TrustedIssuerContract storage self, address _trustedIssuer, uint[] calldata _claimTopics) internal {\n        TrustedIssuer memory trustedIssuer = _getTrustedIssuer(\n            self,\n            address(_trustedIssuer)\n        );\n        trustedIssuer.claimTopics = _claimTopics;\n        _setTrustedIssuer(\n            self,\n            address(_trustedIssuer),\n            trustedIssuer\n        );\n    }\n\n    /// @notice Get the trusted issuers\n    /// @param self The TrustedIssuerContract storage struct\n    /// @return trustedIssuers The trusted issuers\n    function getTrustedIssuers(TrustedIssuerContract storage self) internal view  returns (TrustedIssuer[] memory trustedIssuers) {\n        trustedIssuers = new TrustedIssuer[](self.trustedIssuerAddresses.length);\n        for (uint i = 0; i < self.trustedIssuerAddresses.length; i++) {\n            trustedIssuers[i] = self.trustedIssuers[self.trustedIssuerAddresses[i]];\n        }\n    }\n\n    /// @notice is the issuer trusted\n    /// @param _issuer The address of the issuer\n    /// @return isTrusted True if the issuer is trusted\n    function isTrustedIssuer(address _issuer) internal view returns(bool isTrusted) {\n        isTrusted = trustedIssuerStorage().trustedIssuerContract.trustedIssuers[_issuer].claimIssuer != address(0);\n    }\n\n    /// @notice Get the trusted issuer\n    /// @param _trustedIssuer The trusted issuer\n    /// @return trustedIssuer The trusted issuer\n    function getTrustedIssuerClaimTopics(address _trustedIssuer) external view returns(uint[] memory) {\n        return trustedIssuerStorage().trustedIssuerContract.trustedIssuers[address(_trustedIssuer)].claimTopics;\n    }\n\n    /// @notice Does this issuer have this claim topic\n    /// @param _issuer The address of the issuer\n    /// @param _claimTopic The claim topic\n    /// @return hasTopic True if the issuer has this claim topic\n    function hasClaimTopic(address _issuer, uint _claimTopic) external view returns(bool hasTopic) {\n        uint[] memory claimTopics = trustedIssuerStorage().trustedIssuerContract.trustedIssuers[_issuer].claimTopics;\n        for (uint i = 0; i < claimTopics.length; i++) {\n            if (claimTopics[i] == _claimTopic) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "src/libraries/UInt256Set.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @notice Key sets with enumeration and delete. Uses mappings for random\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\n * fixed gas cost at any scale, O(1).\n * author: Rob Hitchens\n */\n\nlibrary UInt256Set {\n    struct Set {\n        mapping(uint256 => uint256) keyPointers;\n        uint256[] keyList;\n    }\n\n    /**\n     * @notice insert a key.\n     * @dev duplicate keys are not permitted.\n     * @param self storage pointer to a Set.\n     * @param key value to insert.\n     */\n    function insert(Set storage self, uint256 key) public {\n        require(\n            !exists(self, key),\n            \"UInt256Set: key already exists in the set.\"\n        );\n        self.keyList.push(key);\n        self.keyPointers[key] = self.keyList.length - 1;\n    }\n\n    /**\n     * @notice remove a key.\n     * @dev key to remove must exist.\n     * @param self storage pointer to a Set.\n     * @param key value to remove.\n     */\n    function remove(Set storage self, uint256 key) public {\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\n        // require(\n        //     exists(self, key),\n        //     \"UInt256Set: key does not exist in the set.\"\n        // );\n        if (!exists(self, key)) return;\n        uint256 last = count(self) - 1;\n        uint256 rowToReplace = self.keyPointers[key];\n        if (rowToReplace != last) {\n            uint256 keyToMove = self.keyList[last];\n            self.keyPointers[keyToMove] = rowToReplace;\n            self.keyList[rowToReplace] = keyToMove;\n        }\n        delete self.keyPointers[key];\n        delete self.keyList[self.keyList.length - 1];\n    }\n\n    /**\n     * @notice count the keys.\n     * @param self storage pointer to a Set.\n     */\n    function count(Set storage self) public view returns (uint256) {\n        return (self.keyList.length);\n    }\n\n    /**\n     * @notice check if a key is in the Set.\n     * @param self storage pointer to a Set.\n     * @param key value to check.\n     * @return bool true: Set member, false: not a Set member.\n     */\n    function exists(Set storage self, uint256 key)\n        public\n        view\n        returns (bool)\n    {\n        if (self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     * @notice fetch a key by row (enumerate).\n     * @param self storage pointer to a Set.\n     * @param index row to enumerate. Must be < count() - 1.\n     */\n    function keyAtIndex(Set storage self, uint256 index)\n        public\n        view\n        returns (uint256)\n    {\n        return self.keyList[index];\n    }\n}\n"
    },
    "src/tokens/ERC721/ERC721AAttributesFacet.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../../interfaces/IAttribute.sol\";\nimport \"../../libraries/AttributeLib.sol\";\n\nimport \"../../utilities/Modifiers.sol\";\n\n/// @title ERC721AAttributes\n/// @notice the total balance of a token type\ncontract ERC721AAttributesFacet is Modifiers {\n    using AttributeLib for AttributeContract;\n    \n    /// @notice set an attribute for a tokenid keyed by string\n    function _getAttribute(\n        uint256 id,\n        string memory key\n    ) internal view returns (Attribute memory) {\n        AttributeContract storage ct = AttributeLib.attributeStorage().attributes;\n        return ct._getAttribute(id, key);\n    }\n    \n    /// @notice set an attribute to a tokenid keyed by string\n    function _setAttribute(\n        uint256 id,\n        Attribute memory attribute\n    ) internal virtual {\n        AttributeContract storage ct = AttributeLib.attributeStorage().attributes;\n        ct._setAttribute(id, attribute);\n    }\n\n    /// @notice get a list of keys of attributes assigned to this tokenid\n    function _getAttributeKeys(\n        uint256 id\n    ) internal view returns (string[] memory) {\n        AttributeContract storage ct = AttributeLib.attributeStorage().attributes;\n        return ct.attributeKeys[id];\n    }\n\n    /// @notice remove the attribute for a tokenid keyed by string\n    function _removeAttribute(\n        uint256 id,\n        string memory key\n    ) internal virtual {\n        AttributeContract storage ct = AttributeLib.attributeStorage().attributes;\n        ct._removeAttribute(id, key);\n    }\n\n    function getAttributeKeys(\n        uint256 id\n    ) external view returns (string[] memory) {\n        return _getAttributeKeys(id);\n    }\n\n    function getAttribute(\n        uint256 id,\n        string memory key\n    ) external view returns (Attribute memory) {\n        return _getAttribute(id, key);\n    }\n\n    /// @notice set an attribute value\n    function setAttribute(uint256 id, Attribute memory attrib) external onlyOwner {\n        _setAttribute(id, attrib);\n    }\n}  \n"
    },
    "src/tokens/ERC721/ERC721AFacet.sol": {
      "content": "  // SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../../libraries/ERC721ALib.sol\";\nimport \"../../utilities/Modifiers.sol\";\n\n/* solhint-disable mark-callable-contracts */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable no-unused-vars */\n/* solhint-disable two-lines-top-level-separator */\n/* solhint-disable indent */\n/* solhint-disable func-order */\ncontract ERC721AFacet is Context, Initializable, Modifiers {\n\n    using Address for address;\n    using Strings for uint256;\n    using ERC721ALib for ERC721AContract;\n\n    event ERC721ATransfer(address indexed from, address indexed to, uint256 indexed tokenId, bytes data);\n\n    /// @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /// @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /// @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /// @dev See {IERC721Enumerable-totalSupply}.\n    function totalSupply() external view returns (uint256) {\n        return ERC721ALib.erc721aStorage().erc721Contract.totalSupply();\n    }\n\n    /// @dev See {IERC721-balanceOf}.\n    function balanceOf(address owner) external view returns (uint256) {\n        return ERC721ALib.erc721aStorage().erc721Contract.balanceOf(owner);\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\n        return ERC721ALib.erc721aStorage().erc721Contract.ownershipOf(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        return ownershipOf(tokenId).addr;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) external {\n        address owner = ERC721AFacet.ownerOf(tokenId);\n        if (to == owner) revert ApprovalToCurrentOwner();\n\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\n            revert ApprovalCallerNotOwnerNorApproved();\n        }\n        _approve(to, tokenId, owner);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) external view returns (address) {\n        return ERC721ALib.erc721aStorage().erc721Contract.getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        if (operator == _msgSender()) revert ApproveToCaller();\n        ERC721ALib.erc721aStorage().erc721Contract.\n            setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return ERC721ALib.erc721aStorage().erc721Contract.isApprovedForAll(owner, operator);\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual {\n        _transfer(from, to, tokenId);\n        emit ERC721ATransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external virtual {\n        _transfer(from, to, tokenId);\n        emit ERC721ATransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, _data)) {\n            revert TransferToNonERC721ReceiverImplementer();\n        }\n        emit ERC721ATransfer(from, to, tokenId, _data);\n    }\n\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, \"\");\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, \n     * which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        _mint(to, quantity, _data, true);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address().\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {\n        ERC721ALib.erc721aStorage().erc721Contract._mint(msg.sender, to, quantity, _data, safe);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address().\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        ERC721ALib.erc721aStorage().erc721Contract._transfer(msg.sender, from, to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        ERC721ALib.erc721aStorage().erc721Contract._burn(tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {\n        ERC721ALib.erc721aStorage().erc721Contract._tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address().\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        return ERC721ALib._checkOnERC721Received(msg.sender, from, to, tokenId, _data);\n    }\n}\n"
    },
    "src/tokens/ERC721/ERC721AMetadataFacet.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../../libraries/LibDiamond.sol\";\nimport \"../../libraries/MetadataLib.sol\";\nimport \"../../libraries/AttributeLib.sol\";\nimport \"../../libraries/DiamondLib.sol\";\nimport \"../../libraries/ERC721ALib.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../../utilities/Modifiers.sol\";\n\n/* solhint-disable mark-callable-contracts */\n/* solhint-disable var-name-mixedcase */\n/* solhint-disable no-unused-vars */\n/* solhint-disable two-lines-top-level-separator */\n/* solhint-disable indent */\n\n\ncontract ERC721AMetadataFacet is Modifiers {\n\n    using MetadataLib for MetadataContract;\n    using ERC721ALib for ERC721AContract;\n    using Strings for uint256;\n\n    function setMetadata(MetadataContract memory _contract) external {\n\n        LibDiamond.enforceIsContractOwner();\n        MetadataLib.metadataStorage().metadata.setMetadata(_contract);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() external view returns (string memory) {\n\n        // solhint-disable-next-lsine\n        return MetadataLib.metadataStorage().metadata.name();\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() external view returns (string memory) {\n\n        // solhint-disable-next-line\n        return MetadataLib.metadataStorage().metadata.symbol();\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function description() external view returns (string memory) {\n\n        // solhint-disable-next-line\n        return MetadataLib.metadataStorage().metadata.description();\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function image() external view returns (string memory) {\n\n        // solhint-disable-next-line\n        return MetadataLib.metadataStorage().metadata.image();\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function externalUri() external view returns (string memory) {\n\n        // solhint-disable-next-line\n        return MetadataLib.metadataStorage().metadata._externalUri;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function baseUri() external view returns (string memory) {\n\n        // solhint-disable-next-line\n        return MetadataLib.metadataStorage().metadata._externalUri;\n    }\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n\n        ERC721AContract storage erc721Contract = ERC721ALib.erc721aStorage().erc721Contract;        \n        if (!erc721Contract._exists(tokenId)) revert URIQueryForNonexistentToken();\n        \n        MetadataContract storage metadata = MetadataLib.metadataStorage().metadata;\n        if(metadata._metadataSource == MetadataSource.EXTERNAL) {\n            return string(\n                abi.encodePacked(\n                    metadata._baseUri, \n                    uint256(uint160(address(this))).toHexString(),\n                    \"/\",\n                    tokenId.toString())\n                );\n        } else {\n            AttributeContract storage attributes = AttributeLib.attributeStorage().attributes;\n            DiamondContract storage diamond = DiamondLib.diamondStorage().diamondContract;\n            return metadata.tokenURI(diamond, attributes, tokenId);\n        }\n    }\n\n    function setMetadataSource(MetadataSource _source) external {\n        LibDiamond.enforceIsContractOwner();\n        MetadataLib.metadataStorage().metadata._setMetadataSource(_source);\n    }\n\n    function setBaseUri(string memory _baseUri) external {\n        LibDiamond.enforceIsContractOwner();\n        MetadataLib.metadataStorage().metadata._setBaseURI(_baseUri);\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts().\n     */\n    function contractURI() external view returns (string memory) {\n\n        MetadataContract storage metadata = MetadataLib.metadataStorage().metadata;\n        Trait[] memory dum;\n        if(metadata._metadataSource == MetadataSource.EXTERNAL) {\n            return string(\n                abi.encodePacked(\n                    metadata._baseUri, \n                    uint256(uint160(address(this))).toHexString())\n                );\n        } else {\n            (, string memory svg) = metadata.getContractImage();\n            string memory json = Base64.encode(\n                bytes(\n                    metadata.getTokenMetadata(dum, svg)\n                )\n            );\n            return string(abi.encodePacked(\"data:application/json;base64,\", json));\n        }\n\n    }\n}\n"
    },
    "src/tokens/ERC721/ERC721AReceiverFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\npragma solidity ^0.8.6;\n\n\n/**\n * @dev Enables the diamond to receiver erc1155 tokens. This contract also requires \n * supportsInterface to support ERC721. This is implemenented in the DiamondInit contract.\n */\ncontract ERC721AReceiverFacet {\n\n    /// @notice on erc1155 received - return this function selector to allow transfer of tokens\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    \n}\n"
    },
    "src/tokens/ERC721/ERC721EnumerableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\npragma solidity ^0.8.6;\n\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nimport \"../../libraries/ERC721ALib.sol\";\nimport \"../../libraries/ERC721AEnumerationLib.sol\";\n\nimport \"../../interfaces/IERC721Enumerable.sol\";\n\nimport \"../../utilities/Modifiers.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\ncontract ERC721EnumerableFacet is Modifiers {\n\n    using ERC721AEnumerationLib for ERC721EnumerableContract;\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view virtual returns (uint256) {\n        ERC721EnumerableContract storage ds = ERC721ALib.erc721aStorage().enumerations;\n        return ds.tokenOfOwnerByIndex(owner, index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) external view virtual returns (uint256) {\n        ERC721EnumerableContract storage ds = ERC721ALib.erc721aStorage().enumerations;\n        return ds.tokenByIndex(index);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) internal {\n        ERC721EnumerableContract storage ds = ERC721ALib.erc721aStorage().enumerations;\n        return ds._addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) internal {\n        ERC721EnumerableContract storage ds = ERC721ALib.erc721aStorage().enumerations;\n        return ds._addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) internal {\n        ERC721EnumerableContract storage ds = ERC721ALib.erc721aStorage().enumerations;\n        return ds._removeTokenFromOwnerEnumeration(from, tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) internal {\n        ERC721EnumerableContract storage ds = ERC721ALib.erc721aStorage().enumerations;\n        return ds._removeTokenFromAllTokensEnumeration(tokenId);\n    }\n    \n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        ERC721EnumerableContract storage ds = ERC721ALib.erc721aStorage().enumerations;\n        if (from == address(0)) {\n            ds._addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            ds._removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            ds._removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            ds._addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n}\n"
    },
    "src/tokens/ERC721/ERC721MinterFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"../../interfaces/IERC721Mint.sol\";\nimport \"../../utilities/Modifiers.sol\";\n\nimport \"../../libraries/UInt256Set.sol\";\nimport \"../../libraries/ERC721ALib.sol\";\n\ncontract ERC721MinterFacet is Modifiers, IERC721Mint {\n\n    using ERC721ALib for ERC721AContract;\n    using UInt256Set for UInt256Set.Set;\n\n    event ERC721Minted(address indexed to, uint256 indexed tokenId, bytes data);\n    event ERC721BatchMinted(address indexed to, uint256[] indexed tokenIds, bytes data);\n\n    /// @notice mint tokens of specified amount to the specified address\n    function mint(\n        uint256 quantity,\n        bytes memory data\n    ) external override onlyOwner returns (uint256) {\n        ERC721ALib.erc721aStorage().erc721Contract._mint(\n            address(this),\n            address(this),\n            quantity,\n            data,\n            true\n        );\n        emit ERC721Minted(address(this), quantity, data);\n        return ERC721ALib.erc721aStorage().erc721Contract._currentIndex - 1;\n    }\n\n    /// @notice mint tokens of specified amount to the specified address\n    /// @param receiver the mint target\n    function mintTo(\n        address receiver,\n        uint256 quantity,\n        bytes memory data\n    ) external override onlyOwner returns (uint256 tokenId) {\n        ERC721ALib.erc721aStorage().erc721Contract._mint(\n            address(this),\n            receiver,\n            quantity,   \n            data,\n            true\n        );\n        emit ERC721Minted(receiver, quantity, data);\n        return ERC721ALib.erc721aStorage().erc721Contract._currentIndex - 1;\n    }\n\n}\n"
    },
    "src/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {    \n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init() external {        \n\n    }\n\n}\n"
    },
    "src/upgradeInitializers/DynamicDiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\ninterface IDiamondFacetInit is IERC165 {\n    function initializeFacet(\n        address _owner, \n        IDiamondCut.FacetCut memory _facet,\n        bytes calldata _calldata) external;\n}\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {    \n\n    function init(bytes memory initParams) external {        \n\n    }\n\n}\n"
    },
    "src/utilities/Controllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../interfaces/IControllable.sol\";\r\n\r\nabstract contract Controllable is IControllable {\r\n    mapping(address => bool) internal _controllers;\r\n\r\n    /**\r\n     * @dev Throws if called by any account not in authorized list\r\n     */\r\n    modifier onlyController() virtual {\r\n        require(\r\n            _controllers[msg.sender] == true || address(this) == msg.sender,\r\n            \"caller is not a controller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Add an address allowed to control this contract\r\n     */\r\n    function addController(address _controller)\r\n        external\r\n        override\r\n        onlyController\r\n    {\r\n        _addController(_controller);\r\n    }\r\n    function _addController(address _controller) internal {\r\n        _controllers[_controller] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if this address is a controller\r\n     */\r\n    function isController(address _address)\r\n        external\r\n        view\r\n        override\r\n        returns (bool allowed)\r\n    {\r\n        allowed = _isController(_address);\r\n    }\r\n    function _isController(address _address)\r\n        internal view\r\n        returns (bool allowed)\r\n    {\r\n        allowed = _controllers[_address];\r\n    }\r\n\r\n    /**\r\n     * @dev Remove the sender address from the list of controllers\r\n     */\r\n    function relinquishControl() external override onlyController {\r\n        _relinquishControl();\r\n    }\r\n    function _relinquishControl() internal onlyController{\r\n        delete _controllers[msg.sender];\r\n    }\r\n}\r\n"
    },
    "src/utilities/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../libraries/LibDiamond.sol\";\n\ncontract Modifiers {\n\n    modifier onlyOwner() {\n        require(LibDiamond.contractOwner() == msg.sender || address(this) == msg.sender,\n            \"not authorized to call function\");\n        _;\n    }\n\n    // function owner() public view returns (address) {\n    //     return LibDiamond.contractOwner();\n    // }\n\n}"
    },
    "src/utilities/MultipartData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../libraries/SVGTemplatesLib.sol\";\n\nimport \"../interfaces/IMultiPart.sol\";\n\nabstract contract MultipartData  {\n    /// @notice add a new multipart to the contract\n    /// @param _data the data of the multipart\n    function _addData(bytes memory _data)\n        internal returns (uint256 _index) {\n        _index = SVGTemplatesLib.svgStorage().multiPart.data_.length;\n        SVGTemplatesLib.svgStorage().multiPart.data_.push(_data);\n    }\n\n    /// @notice get the data of the given index\n    /// @param _index the index of the data\n    function _getData(uint256 _index)\n        internal view  returns (bytes memory data) {\n        data = SVGTemplatesLib.svgStorage().multiPart.data_[_index];\n    }\n\n    /// @notice get the data as a string\n    function _fromBytes() internal view returns (string memory output) {\n        string memory result = \"\";\n        for (uint256 i = 0; i < SVGTemplatesLib.svgStorage().multiPart.data_.length; i++) {\n            result = string(abi.encodePacked(result, SVGTemplatesLib.svgStorage().multiPart.data_[i]));\n        }\n        output = result;\n    }\n\n    /// @notice get the data as a  bytes array\n    function data__() internal view returns (bytes[] storage) {\n        return SVGTemplatesLib.svgStorage().multiPart.data_;\n    }\n\n    /// @notice clear the contents of the data array\n    function _clear() internal {\n        delete SVGTemplatesLib.svgStorage().multiPart.data_;\n    }\n}"
    },
    "src/utilities/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.6;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"reentrant\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "src/utilities/SVGManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../utilities/Controllable.sol\";\nimport \"../interfaces/ISVG.sol\";\n\nimport \"../interfaces/IStrings.sol\";\n\nimport \"../libraries/StringsLib.sol\";\nimport \"../libraries/SVGTemplatesLib.sol\";\n\ncontract SVGManager is Controllable {\n\n    using SVGTemplatesLib for SVGTemplatesContract;\n\n    event SVGTemplateCreated(string name, address template);\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /// @notice get all the svg namea in the contract\n    function svgs() external view returns (string[] memory) {\n        return SVGTemplatesLib.svgStorage().svgTemplates._svgs();\n    }\n\n    /// @notice get the svg address of the given svg name. does not mean the file exists\n    function svgAddress(string memory _name) external view returns (address _svgAddress) {\n        _svgAddress = SVGTemplatesLib.svgStorage().svgTemplates._svgAddress(_name);\n    }\n\n    /// @notice get the svg data of the given svg name as a string\n    function svgString(string memory _name) external view returns (string memory data_) {\n\n        try SVGTemplate(SVGTemplatesLib.svgStorage().svgTemplates._svgAddress(_name)).svgString() returns (string memory _data) {\n            data_ = _data;\n        } catch (bytes memory) {}\n    }\n\n    /// @notice add a new gem pool\n    function createSVG(address sender, string memory _name) external onlyController returns(address _tplAddress) {\n\n        _tplAddress = SVGTemplatesLib.svgStorage().svgTemplates._createSVG(sender, _name);\n        emit SVGTemplateCreated(_name, _tplAddress);\n    }\n}"
    },
    "src/utilities/SVGTemplate.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../utilities/MultipartData.sol\";\n\nimport \"../libraries/StringsLib.sol\";\nimport \"../libraries/SVGTemplatesLib.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/// @notice a single SVG image\ncontract SVGTemplate is MultipartData, Ownable, Initializable {\n\n    event SVGImageAdded(address indexed _from, address indexed _to, string _name, string _data);\n    event SVGImagePartAdded(address indexed _from, address indexed _to, string _name, string _data);\n\n    function initialize(string memory _name, string[] memory _svg) external initializer {\n        MultiPartContract storage ds = SVGTemplatesLib.svgStorage().multiPart;\n        ds.name_ = _name;\n        for(uint i = 0; i < _svg.length; i++) {\n            ds.data_.push(bytes(_svg[i]));\n        }\n    }\n\n    /// @notice the name of the svg\n    function svgName() external view returns (string memory _name) {\n        MultiPartContract storage ds = SVGTemplatesLib.svgStorage().multiPart;\n        _name = ds.name_;\n    }\n\n    /// @notice the data of the svg\n    function svgString() external view returns (string memory _data) {\n        _data = _fromBytes();\n    }\n\n    /// @notice the data of the svg\n    function svgBytes() external view returns (bytes[] memory _data) {\n        _data = data__();\n    }\n    \n    /// @notice clear the data of the svg\n    function clear() external onlyOwner {\n        _clear();\n    }\n\n    /// @notice add data to the end of the data\n    function add(string memory _data) external onlyOwner returns (uint256 _index) {\n        _index = _addData(bytes(_data));\n        emit SVGImagePartAdded(msg.sender, address(this), SVGTemplatesLib.svgStorage().multiPart.name_, _data);\n    }\n\n    /// @notice add all SVG lines at\n    function addAll(string[] memory _data) external onlyOwner returns (uint256 _count) {\n        for(uint256 i = 0; i < _data.length; i++) {\n            _addData(bytes(_data[i]));\n        }\n        _count = _data.length;\n        MultiPartContract storage ds = SVGTemplatesLib.svgStorage().multiPart;\n        emit SVGImageAdded(msg.sender, address(this), ds.name_, _fromBytes());\n    }\n\n    /// @notice get the svg, replacing the data with the data from the given replacements\n    function buildSVG(Replacement[] memory replacements) external view returns (string memory) {\n        return StringsLib.replace(data__(), replacements);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}